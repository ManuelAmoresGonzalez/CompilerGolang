//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.9.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from D:/ProyectoCompiladores/Grammar\MiniGoParser.g4 by ANTLR 4.9.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace Generated {
using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.9.1")]
[System.CLSCompliant(false)]
public partial class MiniGoParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Package=1, Import=2, Var=3, Type=4, Struct=5, Append=6, Len=7, Cap=8, 
		Print=9, PrintLn=10, Return=11, Break=12, Continue=13, If=14, Func=15, 
		Else=16, For=17, Switch=18, Case=19, Default=20, Comilla=21, LPAREN=22, 
		RPAREN=23, SEMICOLON=24, Asign=25, Coma=26, Puntos=27, CorcheteD=28, CorcheteI=29, 
		LlaveD=30, LlaveI=31, Not=32, Asterisco=33, Slash=34, Porcentaje=35, CorrimientoIzquierda=36, 
		CorrimientoDerecha=37, And=38, AndNot=39, Mas=40, Menos=41, Or=42, DisyuncionExclusiva=43, 
		Equal=44, NotEqual=45, Mayor=46, Menor=47, MenorIgual=48, MayorIgual=49, 
		Land=50, LOR=51, Punto=52, Incremento=53, Decremento=54, Definir=55, SumaIzquierda=56, 
		RestaIzquierda=57, AndValores=58, OrValores=59, MultiIzquierda=60, AsignacionExclusiva=61, 
		AsignCorrimientoIzquierda=62, AsignCorrimientoDerecha=63, AndExclusivo=64, 
		RestarPorcentaje=65, DivisionIzquierda=66, Lower=67, NewLine=68, WS=69, 
		Comments=70, Identifier=71, Letter=72, Int_lit=73, Decimal_lit=74, Binary_lit=75, 
		Octal_lit=76, Hex_lit=77, Decimal_digits=78, Binary_digits=79, Octal_digits=80, 
		Hex_digits=81, Float_Lit=82, Decimal_Float_Lit=83, Decimal_Exponent=84, 
		Hex_Float_List=85, Hex_Mantissa=86, Hex_Exponent=87, Raw_String_Lit=88, 
		Interpreted_String_Lit=89, Rune_Lit=90, Unicode_Value=91, Byte_Value=92, 
		Octal_Byte_Value=93, Hex_Byte_Value=94, Little_U_Value=95, Big_U_Value=96, 
		String_Lit=97, Unicode_Digit=98, Unicode_Letter=99;
	public const int
		RULE_root = 0, RULE_topDeclarationList = 1, RULE_variableDecl = 2, RULE_innerVarDecls = 3, 
		RULE_singleVarDecl = 4, RULE_singleVarDeclNoExps = 5, RULE_typeDecl = 6, 
		RULE_innerTypeDecls = 7, RULE_singleTypeDecl = 8, RULE_funcDecl = 9, RULE_funcFrontDecl = 10, 
		RULE_funcArgDecls = 11, RULE_declType = 12, RULE_sliceDeclType = 13, RULE_arrayDeclType = 14, 
		RULE_structDeclType = 15, RULE_structMemDecls = 16, RULE_identifierList = 17, 
		RULE_expression = 18, RULE_expressionList = 19, RULE_primaryExpression = 20, 
		RULE_operand = 21, RULE_literal = 22, RULE_index = 23, RULE_arguments = 24, 
		RULE_selector = 25, RULE_appendExpression = 26, RULE_lengthExpression = 27, 
		RULE_capExpression = 28, RULE_statementList = 29, RULE_block = 30, RULE_statement = 31, 
		RULE_simpleStatement = 32, RULE_assignmentStatement = 33, RULE_ifStatement = 34, 
		RULE_loop = 35, RULE_switch = 36, RULE_expressionCaseClauseList = 37, 
		RULE_expressionCaseClause = 38, RULE_expressionSwitchCase = 39;
	public static readonly string[] ruleNames = {
		"root", "topDeclarationList", "variableDecl", "innerVarDecls", "singleVarDecl", 
		"singleVarDeclNoExps", "typeDecl", "innerTypeDecls", "singleTypeDecl", 
		"funcDecl", "funcFrontDecl", "funcArgDecls", "declType", "sliceDeclType", 
		"arrayDeclType", "structDeclType", "structMemDecls", "identifierList", 
		"expression", "expressionList", "primaryExpression", "operand", "literal", 
		"index", "arguments", "selector", "appendExpression", "lengthExpression", 
		"capExpression", "statementList", "block", "statement", "simpleStatement", 
		"assignmentStatement", "ifStatement", "loop", "switch", "expressionCaseClauseList", 
		"expressionCaseClause", "expressionSwitchCase"
	};

	private static readonly string[] _LiteralNames = {
		null, "'package'", "'import'", "'var'", "'type'", "'struct'", "'append'", 
		"'len'", "'cap'", "'print'", "'println'", "'return'", "'break'", "'continue'", 
		"'if'", "'func'", "'else'", "'for'", "'switch'", "'case'", "'default'", 
		"'''", "'('", "')'", "';'", "'='", "','", "':'", "'['", "']'", "'{'", 
		"'}'", "'!'", "'*'", "'/'", "'%'", "'<<'", "'>>'", "'&'", "'&^'", "'+'", 
		"'-'", "'|'", "'^'", "'=='", "'!='", "'>'", "'<'", "'<='", "'>='", "'&&'", 
		"'||'", "'.'", "'++'", "'--'", "':='", "'+='", "'-='", "'&='", "'|='", 
		"'*='", "'^='", "'<<='", "'>>='", "'&^='", "'%='", "'/='", "'_'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Package", "Import", "Var", "Type", "Struct", "Append", "Len", "Cap", 
		"Print", "PrintLn", "Return", "Break", "Continue", "If", "Func", "Else", 
		"For", "Switch", "Case", "Default", "Comilla", "LPAREN", "RPAREN", "SEMICOLON", 
		"Asign", "Coma", "Puntos", "CorcheteD", "CorcheteI", "LlaveD", "LlaveI", 
		"Not", "Asterisco", "Slash", "Porcentaje", "CorrimientoIzquierda", "CorrimientoDerecha", 
		"And", "AndNot", "Mas", "Menos", "Or", "DisyuncionExclusiva", "Equal", 
		"NotEqual", "Mayor", "Menor", "MenorIgual", "MayorIgual", "Land", "LOR", 
		"Punto", "Incremento", "Decremento", "Definir", "SumaIzquierda", "RestaIzquierda", 
		"AndValores", "OrValores", "MultiIzquierda", "AsignacionExclusiva", "AsignCorrimientoIzquierda", 
		"AsignCorrimientoDerecha", "AndExclusivo", "RestarPorcentaje", "DivisionIzquierda", 
		"Lower", "NewLine", "WS", "Comments", "Identifier", "Letter", "Int_lit", 
		"Decimal_lit", "Binary_lit", "Octal_lit", "Hex_lit", "Decimal_digits", 
		"Binary_digits", "Octal_digits", "Hex_digits", "Float_Lit", "Decimal_Float_Lit", 
		"Decimal_Exponent", "Hex_Float_List", "Hex_Mantissa", "Hex_Exponent", 
		"Raw_String_Lit", "Interpreted_String_Lit", "Rune_Lit", "Unicode_Value", 
		"Byte_Value", "Octal_Byte_Value", "Hex_Byte_Value", "Little_U_Value", 
		"Big_U_Value", "String_Lit", "Unicode_Digit", "Unicode_Letter"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "MiniGoParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return new string(_serializedATN); } }

	static MiniGoParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public MiniGoParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public MiniGoParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class RootContext : ParserRuleContext {
		public RootContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_root; } }
	 
		public RootContext() { }
		public virtual void CopyFrom(RootContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class MainContext : RootContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Package() { return GetToken(MiniGoParser.Package, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(MiniGoParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TopDeclarationListContext topDeclarationList() {
			return GetRuleContext<TopDeclarationListContext>(0);
		}
		public MainContext(RootContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMain(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RootContext root() {
		RootContext _localctx = new RootContext(Context, State);
		EnterRule(_localctx, 0, RULE_root);
		try {
			_localctx = new MainContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 80;
			Match(Package);
			State = 81;
			Match(Identifier);
			State = 82;
			Match(SEMICOLON);
			State = 83;
			topDeclarationList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TopDeclarationListContext : ParserRuleContext {
		public TopDeclarationListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_topDeclarationList; } }
	 
		public TopDeclarationListContext() { }
		public virtual void CopyFrom(TopDeclarationListContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class EstructuraProyectoContext : TopDeclarationListContext {
		[System.Diagnostics.DebuggerNonUserCode] public VariableDeclContext[] variableDecl() {
			return GetRuleContexts<VariableDeclContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableDeclContext variableDecl(int i) {
			return GetRuleContext<VariableDeclContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeDeclContext[] typeDecl() {
			return GetRuleContexts<TypeDeclContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeDeclContext typeDecl(int i) {
			return GetRuleContext<TypeDeclContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FuncDeclContext[] funcDecl() {
			return GetRuleContexts<FuncDeclContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FuncDeclContext funcDecl(int i) {
			return GetRuleContext<FuncDeclContext>(i);
		}
		public EstructuraProyectoContext(TopDeclarationListContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEstructuraProyecto(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TopDeclarationListContext topDeclarationList() {
		TopDeclarationListContext _localctx = new TopDeclarationListContext(Context, State);
		EnterRule(_localctx, 2, RULE_topDeclarationList);
		int _la;
		try {
			_localctx = new EstructuraProyectoContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 90;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Var) | (1L << Type) | (1L << Func))) != 0)) {
				{
				State = 88;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case Var:
					{
					State = 85;
					variableDecl();
					}
					break;
				case Type:
					{
					State = 86;
					typeDecl();
					}
					break;
				case Func:
					{
					State = 87;
					funcDecl();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 92;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableDeclContext : ParserRuleContext {
		public VariableDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variableDecl; } }
	 
		public VariableDeclContext() { }
		public virtual void CopyFrom(VariableDeclContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class VariableDeclCombinadaContext : VariableDeclContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Var() { return GetToken(MiniGoParser.Var, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(MiniGoParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public InnerVarDeclsContext innerVarDecls() {
			return GetRuleContext<InnerVarDeclsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(MiniGoParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		public VariableDeclCombinadaContext(VariableDeclContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariableDeclCombinada(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VariableDeclVaciaContext : VariableDeclContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Var() { return GetToken(MiniGoParser.Var, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(MiniGoParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(MiniGoParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		public VariableDeclVaciaContext(VariableDeclContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariableDeclVacia(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VariableDeclFormalContext : VariableDeclContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Var() { return GetToken(MiniGoParser.Var, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleVarDeclContext singleVarDecl() {
			return GetRuleContext<SingleVarDeclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		public VariableDeclFormalContext(VariableDeclContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariableDeclFormal(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariableDeclContext variableDecl() {
		VariableDeclContext _localctx = new VariableDeclContext(Context, State);
		EnterRule(_localctx, 4, RULE_variableDecl);
		try {
			State = 107;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,2,Context) ) {
			case 1:
				_localctx = new VariableDeclFormalContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 93;
				Match(Var);
				State = 94;
				singleVarDecl();
				State = 95;
				Match(SEMICOLON);
				}
				break;
			case 2:
				_localctx = new VariableDeclCombinadaContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 97;
				Match(Var);
				State = 98;
				Match(LPAREN);
				State = 99;
				innerVarDecls();
				State = 100;
				Match(RPAREN);
				State = 101;
				Match(SEMICOLON);
				}
				break;
			case 3:
				_localctx = new VariableDeclVaciaContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 103;
				Match(Var);
				State = 104;
				Match(LPAREN);
				State = 105;
				Match(RPAREN);
				State = 106;
				Match(SEMICOLON);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InnerVarDeclsContext : ParserRuleContext {
		public InnerVarDeclsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_innerVarDecls; } }
	 
		public InnerVarDeclsContext() { }
		public virtual void CopyFrom(InnerVarDeclsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DeclararVariablesInternasContext : InnerVarDeclsContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleVarDeclContext[] singleVarDecl() {
			return GetRuleContexts<SingleVarDeclContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleVarDeclContext singleVarDecl(int i) {
			return GetRuleContext<SingleVarDeclContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] SEMICOLON() { return GetTokens(MiniGoParser.SEMICOLON); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON(int i) {
			return GetToken(MiniGoParser.SEMICOLON, i);
		}
		public DeclararVariablesInternasContext(InnerVarDeclsContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclararVariablesInternas(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InnerVarDeclsContext innerVarDecls() {
		InnerVarDeclsContext _localctx = new InnerVarDeclsContext(Context, State);
		EnterRule(_localctx, 6, RULE_innerVarDecls);
		int _la;
		try {
			_localctx = new DeclararVariablesInternasContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 109;
			singleVarDecl();
			State = 110;
			Match(SEMICOLON);
			State = 116;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Identifier) {
				{
				{
				State = 111;
				singleVarDecl();
				State = 112;
				Match(SEMICOLON);
				}
				}
				State = 118;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SingleVarDeclContext : ParserRuleContext {
		public SingleVarDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_singleVarDecl; } }
	 
		public SingleVarDeclContext() { }
		public virtual void CopyFrom(SingleVarDeclContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SingleVarDeclNullContext : SingleVarDeclContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleVarDeclNoExpsContext singleVarDeclNoExps() {
			return GetRuleContext<SingleVarDeclNoExpsContext>(0);
		}
		public SingleVarDeclNullContext(SingleVarDeclContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSingleVarDeclNull(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SingleVarDeclAsignExpLContext : SingleVarDeclContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Asign() { return GetToken(MiniGoParser.Asign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public SingleVarDeclAsignExpLContext(SingleVarDeclContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSingleVarDeclAsignExpL(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SingleVarDeclAsignContext : SingleVarDeclContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclTypeContext declType() {
			return GetRuleContext<DeclTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Asign() { return GetToken(MiniGoParser.Asign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public SingleVarDeclAsignContext(SingleVarDeclContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSingleVarDeclAsign(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SingleVarDeclContext singleVarDecl() {
		SingleVarDeclContext _localctx = new SingleVarDeclContext(Context, State);
		EnterRule(_localctx, 8, RULE_singleVarDecl);
		try {
			State = 129;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				_localctx = new SingleVarDeclAsignContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 119;
				identifierList();
				State = 120;
				declType();
				State = 121;
				Match(Asign);
				State = 122;
				expressionList();
				}
				break;
			case 2:
				_localctx = new SingleVarDeclAsignExpLContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 124;
				identifierList();
				State = 125;
				Match(Asign);
				State = 126;
				expressionList();
				}
				break;
			case 3:
				_localctx = new SingleVarDeclNullContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 128;
				singleVarDeclNoExps();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SingleVarDeclNoExpsContext : ParserRuleContext {
		public SingleVarDeclNoExpsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_singleVarDeclNoExps; } }
	 
		public SingleVarDeclNoExpsContext() { }
		public virtual void CopyFrom(SingleVarDeclNoExpsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AsignarVariableSinValorContext : SingleVarDeclNoExpsContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclTypeContext declType() {
			return GetRuleContext<DeclTypeContext>(0);
		}
		public AsignarVariableSinValorContext(SingleVarDeclNoExpsContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAsignarVariableSinValor(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SingleVarDeclNoExpsContext singleVarDeclNoExps() {
		SingleVarDeclNoExpsContext _localctx = new SingleVarDeclNoExpsContext(Context, State);
		EnterRule(_localctx, 10, RULE_singleVarDeclNoExps);
		try {
			_localctx = new AsignarVariableSinValorContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 131;
			identifierList();
			State = 132;
			declType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeDeclContext : ParserRuleContext {
		public TypeDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeDecl; } }
	 
		public TypeDeclContext() { }
		public virtual void CopyFrom(TypeDeclContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class TypeDeclVacioContext : TypeDeclContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Type() { return GetToken(MiniGoParser.Type, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(MiniGoParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(MiniGoParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		public TypeDeclVacioContext(TypeDeclContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeDeclVacio(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypeDeclVariosContext : TypeDeclContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Type() { return GetToken(MiniGoParser.Type, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(MiniGoParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public InnerTypeDeclsContext innerTypeDecls() {
			return GetRuleContext<InnerTypeDeclsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(MiniGoParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		public TypeDeclVariosContext(TypeDeclContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeDeclVarios(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypeDeclUnicoContext : TypeDeclContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Type() { return GetToken(MiniGoParser.Type, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleTypeDeclContext singleTypeDecl() {
			return GetRuleContext<SingleTypeDeclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		public TypeDeclUnicoContext(TypeDeclContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeDeclUnico(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeDeclContext typeDecl() {
		TypeDeclContext _localctx = new TypeDeclContext(Context, State);
		EnterRule(_localctx, 12, RULE_typeDecl);
		try {
			State = 148;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,5,Context) ) {
			case 1:
				_localctx = new TypeDeclUnicoContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 134;
				Match(Type);
				State = 135;
				singleTypeDecl();
				State = 136;
				Match(SEMICOLON);
				}
				break;
			case 2:
				_localctx = new TypeDeclVariosContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 138;
				Match(Type);
				State = 139;
				Match(LPAREN);
				State = 140;
				innerTypeDecls();
				State = 141;
				Match(RPAREN);
				State = 142;
				Match(SEMICOLON);
				}
				break;
			case 3:
				_localctx = new TypeDeclVacioContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 144;
				Match(Type);
				State = 145;
				Match(LPAREN);
				State = 146;
				Match(RPAREN);
				State = 147;
				Match(SEMICOLON);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InnerTypeDeclsContext : ParserRuleContext {
		public InnerTypeDeclsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_innerTypeDecls; } }
	 
		public InnerTypeDeclsContext() { }
		public virtual void CopyFrom(InnerTypeDeclsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DeclaracionInternaContext : InnerTypeDeclsContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleTypeDeclContext[] singleTypeDecl() {
			return GetRuleContexts<SingleTypeDeclContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleTypeDeclContext singleTypeDecl(int i) {
			return GetRuleContext<SingleTypeDeclContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] SEMICOLON() { return GetTokens(MiniGoParser.SEMICOLON); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON(int i) {
			return GetToken(MiniGoParser.SEMICOLON, i);
		}
		public DeclaracionInternaContext(InnerTypeDeclsContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclaracionInterna(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InnerTypeDeclsContext innerTypeDecls() {
		InnerTypeDeclsContext _localctx = new InnerTypeDeclsContext(Context, State);
		EnterRule(_localctx, 14, RULE_innerTypeDecls);
		int _la;
		try {
			_localctx = new DeclaracionInternaContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 150;
			singleTypeDecl();
			State = 151;
			Match(SEMICOLON);
			State = 157;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Identifier) {
				{
				{
				State = 152;
				singleTypeDecl();
				State = 153;
				Match(SEMICOLON);
				}
				}
				State = 159;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SingleTypeDeclContext : ParserRuleContext {
		public SingleTypeDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_singleTypeDecl; } }
	 
		public SingleTypeDeclContext() { }
		public virtual void CopyFrom(SingleTypeDeclContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class IdentificadorTipoContext : SingleTypeDeclContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(MiniGoParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DeclTypeContext declType() {
			return GetRuleContext<DeclTypeContext>(0);
		}
		public IdentificadorTipoContext(SingleTypeDeclContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentificadorTipo(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SingleTypeDeclContext singleTypeDecl() {
		SingleTypeDeclContext _localctx = new SingleTypeDeclContext(Context, State);
		EnterRule(_localctx, 16, RULE_singleTypeDecl);
		try {
			_localctx = new IdentificadorTipoContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 160;
			Match(Identifier);
			State = 161;
			declType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FuncDeclContext : ParserRuleContext {
		public FuncDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_funcDecl; } }
	 
		public FuncDeclContext() { }
		public virtual void CopyFrom(FuncDeclContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class EstructuraFuncionContext : FuncDeclContext {
		[System.Diagnostics.DebuggerNonUserCode] public FuncFrontDeclContext funcFrontDecl() {
			return GetRuleContext<FuncFrontDeclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		public EstructuraFuncionContext(FuncDeclContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEstructuraFuncion(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FuncDeclContext funcDecl() {
		FuncDeclContext _localctx = new FuncDeclContext(Context, State);
		EnterRule(_localctx, 18, RULE_funcDecl);
		try {
			_localctx = new EstructuraFuncionContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 163;
			funcFrontDecl();
			State = 164;
			block();
			State = 165;
			Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FuncFrontDeclContext : ParserRuleContext {
		public FuncFrontDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_funcFrontDecl; } }
	 
		public FuncFrontDeclContext() { }
		public virtual void CopyFrom(FuncFrontDeclContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DeclararFuncionContext : FuncFrontDeclContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Func() { return GetToken(MiniGoParser.Func, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(MiniGoParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(MiniGoParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(MiniGoParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FuncArgDeclsContext funcArgDecls() {
			return GetRuleContext<FuncArgDeclsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclTypeContext declType() {
			return GetRuleContext<DeclTypeContext>(0);
		}
		public DeclararFuncionContext(FuncFrontDeclContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclararFuncion(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FuncFrontDeclContext funcFrontDecl() {
		FuncFrontDeclContext _localctx = new FuncFrontDeclContext(Context, State);
		EnterRule(_localctx, 20, RULE_funcFrontDecl);
		try {
			_localctx = new DeclararFuncionContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 167;
			Match(Func);
			State = 168;
			Match(Identifier);
			State = 169;
			Match(LPAREN);
			State = 172;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				{
				State = 170;
				funcArgDecls();
				}
				break;
			case RPAREN:
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 174;
			Match(RPAREN);
			State = 177;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Struct:
			case LPAREN:
			case CorcheteD:
			case Identifier:
				{
				State = 175;
				declType();
				}
				break;
			case LlaveD:
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FuncArgDeclsContext : ParserRuleContext {
		public FuncArgDeclsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_funcArgDecls; } }
	 
		public FuncArgDeclsContext() { }
		public virtual void CopyFrom(FuncArgDeclsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ParametrosFuncionContext : FuncArgDeclsContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleVarDeclNoExpsContext[] singleVarDeclNoExps() {
			return GetRuleContexts<SingleVarDeclNoExpsContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleVarDeclNoExpsContext singleVarDeclNoExps(int i) {
			return GetRuleContext<SingleVarDeclNoExpsContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Coma() { return GetTokens(MiniGoParser.Coma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Coma(int i) {
			return GetToken(MiniGoParser.Coma, i);
		}
		public ParametrosFuncionContext(FuncArgDeclsContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParametrosFuncion(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FuncArgDeclsContext funcArgDecls() {
		FuncArgDeclsContext _localctx = new FuncArgDeclsContext(Context, State);
		EnterRule(_localctx, 22, RULE_funcArgDecls);
		int _la;
		try {
			_localctx = new ParametrosFuncionContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 179;
			singleVarDeclNoExps();
			State = 184;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Coma) {
				{
				{
				State = 180;
				Match(Coma);
				State = 181;
				singleVarDeclNoExps();
				}
				}
				State = 186;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclTypeContext : ParserRuleContext {
		public DeclTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declType; } }
	 
		public DeclTypeContext() { }
		public virtual void CopyFrom(DeclTypeContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DeclTypeDeclaracionArregloContext : DeclTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ArrayDeclTypeContext arrayDeclType() {
			return GetRuleContext<ArrayDeclTypeContext>(0);
		}
		public DeclTypeDeclaracionArregloContext(DeclTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclTypeDeclaracionArreglo(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DeclTypeEstructuraDecTipoContext : DeclTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public StructDeclTypeContext structDeclType() {
			return GetRuleContext<StructDeclTypeContext>(0);
		}
		public DeclTypeEstructuraDecTipoContext(DeclTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclTypeEstructuraDecTipo(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DeclTypeParentesisContext : DeclTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(MiniGoParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DeclTypeContext declType() {
			return GetRuleContext<DeclTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(MiniGoParser.RPAREN, 0); }
		public DeclTypeParentesisContext(DeclTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclTypeParentesis(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DeclTypeDeclaracionSimpleContext : DeclTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public SliceDeclTypeContext sliceDeclType() {
			return GetRuleContext<SliceDeclTypeContext>(0);
		}
		public DeclTypeDeclaracionSimpleContext(DeclTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclTypeDeclaracionSimple(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DeclTypeIdentificadorContext : DeclTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(MiniGoParser.Identifier, 0); }
		public DeclTypeIdentificadorContext(DeclTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclTypeIdentificador(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclTypeContext declType() {
		DeclTypeContext _localctx = new DeclTypeContext(Context, State);
		EnterRule(_localctx, 24, RULE_declType);
		try {
			State = 195;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				_localctx = new DeclTypeParentesisContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 187;
				Match(LPAREN);
				State = 188;
				declType();
				State = 189;
				Match(RPAREN);
				}
				break;
			case 2:
				_localctx = new DeclTypeIdentificadorContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 191;
				Match(Identifier);
				}
				break;
			case 3:
				_localctx = new DeclTypeDeclaracionSimpleContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 192;
				sliceDeclType();
				}
				break;
			case 4:
				_localctx = new DeclTypeDeclaracionArregloContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 193;
				arrayDeclType();
				}
				break;
			case 5:
				_localctx = new DeclTypeEstructuraDecTipoContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 194;
				structDeclType();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SliceDeclTypeContext : ParserRuleContext {
		public SliceDeclTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sliceDeclType; } }
	 
		public SliceDeclTypeContext() { }
		public virtual void CopyFrom(SliceDeclTypeContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DeclaracionVaciaContext : SliceDeclTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CorcheteD() { return GetToken(MiniGoParser.CorcheteD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CorcheteI() { return GetToken(MiniGoParser.CorcheteI, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DeclTypeContext declType() {
			return GetRuleContext<DeclTypeContext>(0);
		}
		public DeclaracionVaciaContext(SliceDeclTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclaracionVacia(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SliceDeclTypeContext sliceDeclType() {
		SliceDeclTypeContext _localctx = new SliceDeclTypeContext(Context, State);
		EnterRule(_localctx, 26, RULE_sliceDeclType);
		try {
			_localctx = new DeclaracionVaciaContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 197;
			Match(CorcheteD);
			State = 198;
			Match(CorcheteI);
			State = 199;
			declType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrayDeclTypeContext : ParserRuleContext {
		public ArrayDeclTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrayDeclType; } }
	 
		public ArrayDeclTypeContext() { }
		public virtual void CopyFrom(ArrayDeclTypeContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DeclaracionIntContext : ArrayDeclTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CorcheteD() { return GetToken(MiniGoParser.CorcheteD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Int_lit() { return GetToken(MiniGoParser.Int_lit, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CorcheteI() { return GetToken(MiniGoParser.CorcheteI, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DeclTypeContext declType() {
			return GetRuleContext<DeclTypeContext>(0);
		}
		public DeclaracionIntContext(ArrayDeclTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclaracionInt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrayDeclTypeContext arrayDeclType() {
		ArrayDeclTypeContext _localctx = new ArrayDeclTypeContext(Context, State);
		EnterRule(_localctx, 28, RULE_arrayDeclType);
		try {
			_localctx = new DeclaracionIntContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 201;
			Match(CorcheteD);
			State = 202;
			Match(Int_lit);
			State = 203;
			Match(CorcheteI);
			State = 204;
			declType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructDeclTypeContext : ParserRuleContext {
		public StructDeclTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structDeclType; } }
	 
		public StructDeclTypeContext() { }
		public virtual void CopyFrom(StructDeclTypeContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class EstructuraLlavesContext : StructDeclTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Struct() { return GetToken(MiniGoParser.Struct, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LlaveD() { return GetToken(MiniGoParser.LlaveD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LlaveI() { return GetToken(MiniGoParser.LlaveI, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StructMemDeclsContext structMemDecls() {
			return GetRuleContext<StructMemDeclsContext>(0);
		}
		public EstructuraLlavesContext(StructDeclTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEstructuraLlaves(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructDeclTypeContext structDeclType() {
		StructDeclTypeContext _localctx = new StructDeclTypeContext(Context, State);
		EnterRule(_localctx, 30, RULE_structDeclType);
		try {
			_localctx = new EstructuraLlavesContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 206;
			Match(Struct);
			State = 207;
			Match(LlaveD);
			State = 210;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				{
				State = 208;
				structMemDecls();
				}
				break;
			case LlaveI:
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 212;
			Match(LlaveI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructMemDeclsContext : ParserRuleContext {
		public StructMemDeclsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structMemDecls; } }
	 
		public StructMemDeclsContext() { }
		public virtual void CopyFrom(StructMemDeclsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class PartesCodigoContext : StructMemDeclsContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleVarDeclNoExpsContext[] singleVarDeclNoExps() {
			return GetRuleContexts<SingleVarDeclNoExpsContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleVarDeclNoExpsContext singleVarDeclNoExps(int i) {
			return GetRuleContext<SingleVarDeclNoExpsContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] SEMICOLON() { return GetTokens(MiniGoParser.SEMICOLON); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON(int i) {
			return GetToken(MiniGoParser.SEMICOLON, i);
		}
		public PartesCodigoContext(StructMemDeclsContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartesCodigo(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructMemDeclsContext structMemDecls() {
		StructMemDeclsContext _localctx = new StructMemDeclsContext(Context, State);
		EnterRule(_localctx, 32, RULE_structMemDecls);
		int _la;
		try {
			_localctx = new PartesCodigoContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 214;
			singleVarDeclNoExps();
			State = 215;
			Match(SEMICOLON);
			State = 221;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Identifier) {
				{
				{
				State = 216;
				singleVarDeclNoExps();
				State = 217;
				Match(SEMICOLON);
				}
				}
				State = 223;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierListContext : ParserRuleContext {
		public IdentifierListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierList; } }
	 
		public IdentifierListContext() { }
		public virtual void CopyFrom(IdentifierListContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ListarIdentificadoresContext : IdentifierListContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(MiniGoParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(MiniGoParser.Identifier, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Coma() { return GetTokens(MiniGoParser.Coma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Coma(int i) {
			return GetToken(MiniGoParser.Coma, i);
		}
		public ListarIdentificadoresContext(IdentifierListContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitListarIdentificadores(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierListContext identifierList() {
		IdentifierListContext _localctx = new IdentifierListContext(Context, State);
		EnterRule(_localctx, 34, RULE_identifierList);
		int _la;
		try {
			_localctx = new ListarIdentificadoresContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 224;
			Match(Identifier);
			State = 229;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Coma) {
				{
				{
				State = 225;
				Match(Coma);
				State = 226;
				Match(Identifier);
				}
				}
				State = 231;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ExpressionMenorIgualContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MenorIgual() { return GetToken(MiniGoParser.MenorIgual, 0); }
		public ExpressionMenorIgualContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionMenorIgual(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionAsteriscoContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Asterisco() { return GetToken(MiniGoParser.Asterisco, 0); }
		public ExpressionAsteriscoContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionAsterisco(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionCorrimientoDerechaContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CorrimientoDerecha() { return GetToken(MiniGoParser.CorrimientoDerecha, 0); }
		public ExpressionCorrimientoDerechaContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionCorrimientoDerecha(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionLandContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Land() { return GetToken(MiniGoParser.Land, 0); }
		public ExpressionLandContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionLand(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionMayorIgualContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MayorIgual() { return GetToken(MiniGoParser.MayorIgual, 0); }
		public ExpressionMayorIgualContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionMayorIgual(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NotExpressionContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Not() { return GetToken(MiniGoParser.Not, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public NotExpressionContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNotExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionMayorContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mayor() { return GetToken(MiniGoParser.Mayor, 0); }
		public ExpressionMayorContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionMayor(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionEqualContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Equal() { return GetToken(MiniGoParser.Equal, 0); }
		public ExpressionEqualContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionEqual(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionMasContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mas() { return GetToken(MiniGoParser.Mas, 0); }
		public ExpressionMasContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionMas(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionSlashContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Slash() { return GetToken(MiniGoParser.Slash, 0); }
		public ExpressionSlashContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionSlash(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionDisyuncionExclusiContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DisyuncionExclusiva() { return GetToken(MiniGoParser.DisyuncionExclusiva, 0); }
		public ExpressionDisyuncionExclusiContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionDisyuncionExclusi(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MasExpressionContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mas() { return GetToken(MiniGoParser.Mas, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public MasExpressionContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMasExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionAndNOtContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AndNot() { return GetToken(MiniGoParser.AndNot, 0); }
		public ExpressionAndNOtContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionAndNOt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionPrimaryExpressionContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public PrimaryExpressionContext primaryExpression() {
			return GetRuleContext<PrimaryExpressionContext>(0);
		}
		public ExpressionPrimaryExpressionContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionPrimaryExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionAndContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode And() { return GetToken(MiniGoParser.And, 0); }
		public ExpressionAndContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionAnd(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionCorrimientoIzquiContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CorrimientoIzquierda() { return GetToken(MiniGoParser.CorrimientoIzquierda, 0); }
		public ExpressionCorrimientoIzquiContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionCorrimientoIzqui(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionNotEqualContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NotEqual() { return GetToken(MiniGoParser.NotEqual, 0); }
		public ExpressionNotEqualContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionNotEqual(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MenosExpressionContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Menos() { return GetToken(MiniGoParser.Menos, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public MenosExpressionContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMenosExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DisyuncionExpressionContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DisyuncionExclusiva() { return GetToken(MiniGoParser.DisyuncionExclusiva, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public DisyuncionExpressionContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDisyuncionExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionPorcentajeContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Porcentaje() { return GetToken(MiniGoParser.Porcentaje, 0); }
		public ExpressionPorcentajeContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionPorcentaje(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionOrContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Or() { return GetToken(MiniGoParser.Or, 0); }
		public ExpressionOrContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionOr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionMenorContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Menor() { return GetToken(MiniGoParser.Menor, 0); }
		public ExpressionMenorContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionMenor(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionMenosContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Menos() { return GetToken(MiniGoParser.Menos, 0); }
		public ExpressionMenosContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionMenos(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionLorContext : ExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOR() { return GetToken(MiniGoParser.LOR, 0); }
		public ExpressionLorContext(ExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionLor(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(Context, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 36;
		EnterRecursionRule(_localctx, 36, RULE_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 242;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Append:
			case Len:
			case Cap:
			case LPAREN:
			case Identifier:
			case Int_lit:
			case Float_Lit:
			case Raw_String_Lit:
			case Interpreted_String_Lit:
			case Rune_Lit:
				{
				_localctx = new ExpressionPrimaryExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 233;
				primaryExpression(0);
				}
				break;
			case Mas:
				{
				_localctx = new MasExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 234;
				Match(Mas);
				State = 235;
				expression(4);
				}
				break;
			case Menos:
				{
				_localctx = new MenosExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 236;
				Match(Menos);
				State = 237;
				expression(3);
				}
				break;
			case Not:
				{
				_localctx = new NotExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 238;
				Match(Not);
				State = 239;
				expression(2);
				}
				break;
			case DisyuncionExclusiva:
				{
				_localctx = new DisyuncionExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 240;
				Match(DisyuncionExclusiva);
				State = 241;
				expression(1);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 303;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,16,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 301;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
					case 1:
						{
						_localctx = new ExpressionAsteriscoContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 244;
						if (!(Precpred(Context, 23))) throw new FailedPredicateException(this, "Precpred(Context, 23)");
						State = 245;
						Match(Asterisco);
						State = 246;
						expression(24);
						}
						break;
					case 2:
						{
						_localctx = new ExpressionSlashContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 247;
						if (!(Precpred(Context, 22))) throw new FailedPredicateException(this, "Precpred(Context, 22)");
						State = 248;
						Match(Slash);
						State = 249;
						expression(23);
						}
						break;
					case 3:
						{
						_localctx = new ExpressionPorcentajeContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 250;
						if (!(Precpred(Context, 21))) throw new FailedPredicateException(this, "Precpred(Context, 21)");
						State = 251;
						Match(Porcentaje);
						State = 252;
						expression(22);
						}
						break;
					case 4:
						{
						_localctx = new ExpressionCorrimientoIzquiContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 253;
						if (!(Precpred(Context, 20))) throw new FailedPredicateException(this, "Precpred(Context, 20)");
						State = 254;
						Match(CorrimientoIzquierda);
						State = 255;
						expression(21);
						}
						break;
					case 5:
						{
						_localctx = new ExpressionCorrimientoDerechaContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 256;
						if (!(Precpred(Context, 19))) throw new FailedPredicateException(this, "Precpred(Context, 19)");
						State = 257;
						Match(CorrimientoDerecha);
						State = 258;
						expression(20);
						}
						break;
					case 6:
						{
						_localctx = new ExpressionAndContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 259;
						if (!(Precpred(Context, 18))) throw new FailedPredicateException(this, "Precpred(Context, 18)");
						State = 260;
						Match(And);
						State = 261;
						expression(19);
						}
						break;
					case 7:
						{
						_localctx = new ExpressionAndNOtContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 262;
						if (!(Precpred(Context, 17))) throw new FailedPredicateException(this, "Precpred(Context, 17)");
						State = 263;
						Match(AndNot);
						State = 264;
						expression(18);
						}
						break;
					case 8:
						{
						_localctx = new ExpressionMasContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 265;
						if (!(Precpred(Context, 16))) throw new FailedPredicateException(this, "Precpred(Context, 16)");
						State = 266;
						Match(Mas);
						State = 267;
						expression(17);
						}
						break;
					case 9:
						{
						_localctx = new ExpressionMenosContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 268;
						if (!(Precpred(Context, 15))) throw new FailedPredicateException(this, "Precpred(Context, 15)");
						State = 269;
						Match(Menos);
						State = 270;
						expression(16);
						}
						break;
					case 10:
						{
						_localctx = new ExpressionOrContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 271;
						if (!(Precpred(Context, 14))) throw new FailedPredicateException(this, "Precpred(Context, 14)");
						State = 272;
						Match(Or);
						State = 273;
						expression(15);
						}
						break;
					case 11:
						{
						_localctx = new ExpressionDisyuncionExclusiContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 274;
						if (!(Precpred(Context, 13))) throw new FailedPredicateException(this, "Precpred(Context, 13)");
						State = 275;
						Match(DisyuncionExclusiva);
						State = 276;
						expression(14);
						}
						break;
					case 12:
						{
						_localctx = new ExpressionEqualContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 277;
						if (!(Precpred(Context, 12))) throw new FailedPredicateException(this, "Precpred(Context, 12)");
						State = 278;
						Match(Equal);
						State = 279;
						expression(13);
						}
						break;
					case 13:
						{
						_localctx = new ExpressionNotEqualContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 280;
						if (!(Precpred(Context, 11))) throw new FailedPredicateException(this, "Precpred(Context, 11)");
						State = 281;
						Match(NotEqual);
						State = 282;
						expression(12);
						}
						break;
					case 14:
						{
						_localctx = new ExpressionMenorContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 283;
						if (!(Precpred(Context, 10))) throw new FailedPredicateException(this, "Precpred(Context, 10)");
						State = 284;
						Match(Menor);
						State = 285;
						expression(11);
						}
						break;
					case 15:
						{
						_localctx = new ExpressionMenorIgualContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 286;
						if (!(Precpred(Context, 9))) throw new FailedPredicateException(this, "Precpred(Context, 9)");
						State = 287;
						Match(MenorIgual);
						State = 288;
						expression(10);
						}
						break;
					case 16:
						{
						_localctx = new ExpressionMayorContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 289;
						if (!(Precpred(Context, 8))) throw new FailedPredicateException(this, "Precpred(Context, 8)");
						State = 290;
						Match(Mayor);
						State = 291;
						expression(9);
						}
						break;
					case 17:
						{
						_localctx = new ExpressionMayorIgualContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 292;
						if (!(Precpred(Context, 7))) throw new FailedPredicateException(this, "Precpred(Context, 7)");
						State = 293;
						Match(MayorIgual);
						State = 294;
						expression(8);
						}
						break;
					case 18:
						{
						_localctx = new ExpressionLandContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 295;
						if (!(Precpred(Context, 6))) throw new FailedPredicateException(this, "Precpred(Context, 6)");
						State = 296;
						Match(Land);
						State = 297;
						expression(7);
						}
						break;
					case 19:
						{
						_localctx = new ExpressionLorContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 298;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 299;
						Match(LOR);
						State = 300;
						expression(6);
						}
						break;
					}
					} 
				}
				State = 305;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,16,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ExpressionListContext : ParserRuleContext {
		public ExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionList; } }
	 
		public ExpressionListContext() { }
		public virtual void CopyFrom(ExpressionListContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ExpressionListExpressionContext : ExpressionListContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Coma() { return GetTokens(MiniGoParser.Coma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Coma(int i) {
			return GetToken(MiniGoParser.Coma, i);
		}
		public ExpressionListExpressionContext(ExpressionListContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionListExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionListContext expressionList() {
		ExpressionListContext _localctx = new ExpressionListContext(Context, State);
		EnterRule(_localctx, 38, RULE_expressionList);
		int _la;
		try {
			_localctx = new ExpressionListExpressionContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 306;
			expression(0);
			State = 311;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Coma) {
				{
				{
				State = 307;
				Match(Coma);
				State = 308;
				expression(0);
				}
				}
				State = 313;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrimaryExpressionContext : ParserRuleContext {
		public PrimaryExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_primaryExpression; } }
	 
		public PrimaryExpressionContext() { }
		public virtual void CopyFrom(PrimaryExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class PrimaryExpressionSelectorContext : PrimaryExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public PrimaryExpressionContext primaryExpression() {
			return GetRuleContext<PrimaryExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SelectorContext selector() {
			return GetRuleContext<SelectorContext>(0);
		}
		public PrimaryExpressionSelectorContext(PrimaryExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimaryExpressionSelector(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PrimaryExpressionCapContext : PrimaryExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public CapExpressionContext capExpression() {
			return GetRuleContext<CapExpressionContext>(0);
		}
		public PrimaryExpressionCapContext(PrimaryExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimaryExpressionCap(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PrimaryExpressionOperandContext : PrimaryExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public OperandContext operand() {
			return GetRuleContext<OperandContext>(0);
		}
		public PrimaryExpressionOperandContext(PrimaryExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimaryExpressionOperand(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PrimaryExpressionAppendContext : PrimaryExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public AppendExpressionContext appendExpression() {
			return GetRuleContext<AppendExpressionContext>(0);
		}
		public PrimaryExpressionAppendContext(PrimaryExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimaryExpressionAppend(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PrimaryExpressionArgumentsContext : PrimaryExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public PrimaryExpressionContext primaryExpression() {
			return GetRuleContext<PrimaryExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentsContext arguments() {
			return GetRuleContext<ArgumentsContext>(0);
		}
		public PrimaryExpressionArgumentsContext(PrimaryExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimaryExpressionArguments(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PrimaryExpressionIndexContext : PrimaryExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public PrimaryExpressionContext primaryExpression() {
			return GetRuleContext<PrimaryExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexContext index() {
			return GetRuleContext<IndexContext>(0);
		}
		public PrimaryExpressionIndexContext(PrimaryExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimaryExpressionIndex(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PrimaryExpressionLenghtContext : PrimaryExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public LengthExpressionContext lengthExpression() {
			return GetRuleContext<LengthExpressionContext>(0);
		}
		public PrimaryExpressionLenghtContext(PrimaryExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimaryExpressionLenght(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrimaryExpressionContext primaryExpression() {
		return primaryExpression(0);
	}

	private PrimaryExpressionContext primaryExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		PrimaryExpressionContext _localctx = new PrimaryExpressionContext(Context, _parentState);
		PrimaryExpressionContext _prevctx = _localctx;
		int _startState = 40;
		EnterRecursionRule(_localctx, 40, RULE_primaryExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 319;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
			case Identifier:
			case Int_lit:
			case Float_Lit:
			case Raw_String_Lit:
			case Interpreted_String_Lit:
			case Rune_Lit:
				{
				_localctx = new PrimaryExpressionOperandContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 315;
				operand();
				}
				break;
			case Append:
				{
				_localctx = new PrimaryExpressionAppendContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 316;
				appendExpression();
				}
				break;
			case Len:
				{
				_localctx = new PrimaryExpressionLenghtContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 317;
				lengthExpression();
				}
				break;
			case Cap:
				{
				_localctx = new PrimaryExpressionCapContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 318;
				capExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 329;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,20,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 327;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,19,Context) ) {
					case 1:
						{
						_localctx = new PrimaryExpressionSelectorContext(new PrimaryExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_primaryExpression);
						State = 321;
						if (!(Precpred(Context, 6))) throw new FailedPredicateException(this, "Precpred(Context, 6)");
						State = 322;
						selector();
						}
						break;
					case 2:
						{
						_localctx = new PrimaryExpressionIndexContext(new PrimaryExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_primaryExpression);
						State = 323;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 324;
						index();
						}
						break;
					case 3:
						{
						_localctx = new PrimaryExpressionArgumentsContext(new PrimaryExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_primaryExpression);
						State = 325;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 326;
						arguments();
						}
						break;
					}
					} 
				}
				State = 331;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,20,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class OperandContext : ParserRuleContext {
		public OperandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_operand; } }
	 
		public OperandContext() { }
		public virtual void CopyFrom(OperandContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class OperandoExpresionContext : OperandContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(MiniGoParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(MiniGoParser.RPAREN, 0); }
		public OperandoExpresionContext(OperandContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOperandoExpresion(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OperandoLiteralContext : OperandContext {
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public OperandoLiteralContext(OperandContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOperandoLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OperandoIdentificadorContext : OperandContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(MiniGoParser.Identifier, 0); }
		public OperandoIdentificadorContext(OperandContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOperandoIdentificador(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OperandContext operand() {
		OperandContext _localctx = new OperandContext(Context, State);
		EnterRule(_localctx, 42, RULE_operand);
		try {
			State = 338;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Int_lit:
			case Float_Lit:
			case Raw_String_Lit:
			case Interpreted_String_Lit:
			case Rune_Lit:
				_localctx = new OperandoLiteralContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 332;
				literal();
				}
				break;
			case Identifier:
				_localctx = new OperandoIdentificadorContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 333;
				Match(Identifier);
				}
				break;
			case LPAREN:
				_localctx = new OperandoExpresionContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 334;
				Match(LPAREN);
				State = 335;
				expression(0);
				State = 336;
				Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
	 
		public LiteralContext() { }
		public virtual void CopyFrom(LiteralContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class LiteralRuneContext : LiteralContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Rune_Lit() { return GetToken(MiniGoParser.Rune_Lit, 0); }
		public LiteralRuneContext(LiteralContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralRune(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LiteralLitContext : LiteralContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Int_lit() { return GetToken(MiniGoParser.Int_lit, 0); }
		public LiteralLitContext(LiteralContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralLit(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LiteralRawContext : LiteralContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Raw_String_Lit() { return GetToken(MiniGoParser.Raw_String_Lit, 0); }
		public LiteralRawContext(LiteralContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralRaw(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LiteralInterpretedContext : LiteralContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Interpreted_String_Lit() { return GetToken(MiniGoParser.Interpreted_String_Lit, 0); }
		public LiteralInterpretedContext(LiteralContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralInterpreted(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LiteralFloatContext : LiteralContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Float_Lit() { return GetToken(MiniGoParser.Float_Lit, 0); }
		public LiteralFloatContext(LiteralContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralFloat(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(Context, State);
		EnterRule(_localctx, 44, RULE_literal);
		try {
			State = 345;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Int_lit:
				_localctx = new LiteralLitContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 340;
				Match(Int_lit);
				}
				break;
			case Float_Lit:
				_localctx = new LiteralFloatContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 341;
				Match(Float_Lit);
				}
				break;
			case Rune_Lit:
				_localctx = new LiteralRuneContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 342;
				Match(Rune_Lit);
				}
				break;
			case Raw_String_Lit:
				_localctx = new LiteralRawContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 343;
				Match(Raw_String_Lit);
				}
				break;
			case Interpreted_String_Lit:
				_localctx = new LiteralInterpretedContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 344;
				Match(Interpreted_String_Lit);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexContext : ParserRuleContext {
		public IndexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_index; } }
	 
		public IndexContext() { }
		public virtual void CopyFrom(IndexContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class IndexTipoContext : IndexContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CorcheteD() { return GetToken(MiniGoParser.CorcheteD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CorcheteI() { return GetToken(MiniGoParser.CorcheteI, 0); }
		public IndexTipoContext(IndexContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexTipo(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndexContext index() {
		IndexContext _localctx = new IndexContext(Context, State);
		EnterRule(_localctx, 46, RULE_index);
		try {
			_localctx = new IndexTipoContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 347;
			Match(CorcheteD);
			State = 348;
			expression(0);
			State = 349;
			Match(CorcheteI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentsContext : ParserRuleContext {
		public ArgumentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arguments; } }
	 
		public ArgumentsContext() { }
		public virtual void CopyFrom(ArgumentsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ArgumentosContext : ArgumentsContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(MiniGoParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(MiniGoParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public ArgumentosContext(ArgumentsContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgumentos(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentsContext arguments() {
		ArgumentsContext _localctx = new ArgumentsContext(Context, State);
		EnterRule(_localctx, 48, RULE_arguments);
		try {
			_localctx = new ArgumentosContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 351;
			Match(LPAREN);
			State = 354;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Append:
			case Len:
			case Cap:
			case LPAREN:
			case Not:
			case Mas:
			case Menos:
			case DisyuncionExclusiva:
			case Identifier:
			case Int_lit:
			case Float_Lit:
			case Raw_String_Lit:
			case Interpreted_String_Lit:
			case Rune_Lit:
				{
				State = 352;
				expressionList();
				}
				break;
			case RPAREN:
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 356;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectorContext : ParserRuleContext {
		public SelectorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selector; } }
	 
		public SelectorContext() { }
		public virtual void CopyFrom(SelectorContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SelectorPuntoContext : SelectorContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Punto() { return GetToken(MiniGoParser.Punto, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(MiniGoParser.Identifier, 0); }
		public SelectorPuntoContext(SelectorContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectorPunto(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectorContext selector() {
		SelectorContext _localctx = new SelectorContext(Context, State);
		EnterRule(_localctx, 50, RULE_selector);
		try {
			_localctx = new SelectorPuntoContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 358;
			Match(Punto);
			State = 359;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AppendExpressionContext : ParserRuleContext {
		public AppendExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_appendExpression; } }
	 
		public AppendExpressionContext() { }
		public virtual void CopyFrom(AppendExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ExpresionAppendContext : AppendExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Append() { return GetToken(MiniGoParser.Append, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(MiniGoParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Coma() { return GetToken(MiniGoParser.Coma, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(MiniGoParser.RPAREN, 0); }
		public ExpresionAppendContext(AppendExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpresionAppend(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AppendExpressionContext appendExpression() {
		AppendExpressionContext _localctx = new AppendExpressionContext(Context, State);
		EnterRule(_localctx, 52, RULE_appendExpression);
		try {
			_localctx = new ExpresionAppendContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 361;
			Match(Append);
			State = 362;
			Match(LPAREN);
			State = 363;
			expression(0);
			State = 364;
			Match(Coma);
			State = 365;
			expression(0);
			State = 366;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LengthExpressionContext : ParserRuleContext {
		public LengthExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lengthExpression; } }
	 
		public LengthExpressionContext() { }
		public virtual void CopyFrom(LengthExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ExpresionLenContext : LengthExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Len() { return GetToken(MiniGoParser.Len, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(MiniGoParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(MiniGoParser.RPAREN, 0); }
		public ExpresionLenContext(LengthExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpresionLen(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LengthExpressionContext lengthExpression() {
		LengthExpressionContext _localctx = new LengthExpressionContext(Context, State);
		EnterRule(_localctx, 54, RULE_lengthExpression);
		try {
			_localctx = new ExpresionLenContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 368;
			Match(Len);
			State = 369;
			Match(LPAREN);
			State = 370;
			expression(0);
			State = 371;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CapExpressionContext : ParserRuleContext {
		public CapExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_capExpression; } }
	 
		public CapExpressionContext() { }
		public virtual void CopyFrom(CapExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ExpresionCapContext : CapExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Cap() { return GetToken(MiniGoParser.Cap, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(MiniGoParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(MiniGoParser.RPAREN, 0); }
		public ExpresionCapContext(CapExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpresionCap(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CapExpressionContext capExpression() {
		CapExpressionContext _localctx = new CapExpressionContext(Context, State);
		EnterRule(_localctx, 56, RULE_capExpression);
		try {
			_localctx = new ExpresionCapContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 373;
			Match(Cap);
			State = 374;
			Match(LPAREN);
			State = 375;
			expression(0);
			State = 376;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementListContext : ParserRuleContext {
		public StatementListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statementList; } }
	 
		public StatementListContext() { }
		public virtual void CopyFrom(StatementListContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ListaDeclaracionesContext : StatementListContext {
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public ListaDeclaracionesContext(StatementListContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitListaDeclaraciones(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementListContext statementList() {
		StatementListContext _localctx = new StatementListContext(Context, State);
		EnterRule(_localctx, 58, RULE_statementList);
		int _la;
		try {
			_localctx = new ListaDeclaracionesContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 381;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Var) | (1L << Type) | (1L << Append) | (1L << Len) | (1L << Cap) | (1L << Print) | (1L << PrintLn) | (1L << Return) | (1L << Break) | (1L << Continue) | (1L << If) | (1L << For) | (1L << Switch) | (1L << LPAREN) | (1L << SEMICOLON) | (1L << LlaveD) | (1L << Not) | (1L << Mas) | (1L << Menos) | (1L << DisyuncionExclusiva))) != 0) || ((((_la - 71)) & ~0x3f) == 0 && ((1L << (_la - 71)) & ((1L << (Identifier - 71)) | (1L << (Int_lit - 71)) | (1L << (Float_Lit - 71)) | (1L << (Raw_String_Lit - 71)) | (1L << (Interpreted_String_Lit - 71)) | (1L << (Rune_Lit - 71)))) != 0)) {
				{
				{
				State = 378;
				statement();
				}
				}
				State = 383;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockContext : ParserRuleContext {
		public BlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_block; } }
	 
		public BlockContext() { }
		public virtual void CopyFrom(BlockContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class EstructuraBlockContext : BlockContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LlaveD() { return GetToken(MiniGoParser.LlaveD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementListContext statementList() {
			return GetRuleContext<StatementListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LlaveI() { return GetToken(MiniGoParser.LlaveI, 0); }
		public EstructuraBlockContext(BlockContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEstructuraBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockContext block() {
		BlockContext _localctx = new BlockContext(Context, State);
		EnterRule(_localctx, 60, RULE_block);
		try {
			_localctx = new EstructuraBlockContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 384;
			Match(LlaveD);
			State = 385;
			statementList();
			State = 386;
			Match(LlaveI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
	 
		public StatementContext() { }
		public virtual void CopyFrom(StatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class FuncionRetornarContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Return() { return GetToken(MiniGoParser.Return, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public FuncionRetornarContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncionRetornar(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FuncionImprimirLnContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PrintLn() { return GetToken(MiniGoParser.PrintLn, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(MiniGoParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(MiniGoParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Raw_String_Lit() { return GetToken(MiniGoParser.Raw_String_Lit, 0); }
		public FuncionImprimirLnContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncionImprimirLn(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FuncionContinuarContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Continue() { return GetToken(MiniGoParser.Continue, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		public FuncionContinuarContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncionContinuar(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FuncionBreakContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Break() { return GetToken(MiniGoParser.Break, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		public FuncionBreakContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncionBreak(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FuncionBlockContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		public FuncionBlockContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncionBlock(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FuncionIfContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public IfStatementContext ifStatement() {
			return GetRuleContext<IfStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		public FuncionIfContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncionIf(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DeclararTiposContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeDeclContext typeDecl() {
			return GetRuleContext<TypeDeclContext>(0);
		}
		public DeclararTiposContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclararTipos(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FuncionSwitchContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public SwitchContext @switch() {
			return GetRuleContext<SwitchContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		public FuncionSwitchContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncionSwitch(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpresionSimpleContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public SimpleStatementContext simpleStatement() {
			return GetRuleContext<SimpleStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		public ExpresionSimpleContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpresionSimple(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DeclararVariablesContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public VariableDeclContext variableDecl() {
			return GetRuleContext<VariableDeclContext>(0);
		}
		public DeclararVariablesContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclararVariables(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FuncionImprimirContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Print() { return GetToken(MiniGoParser.Print, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(MiniGoParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(MiniGoParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public FuncionImprimirContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncionImprimir(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FuncionLoopContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public LoopContext loop() {
			return GetRuleContext<LoopContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		public FuncionLoopContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncionLoop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 62, RULE_statement);
		try {
			State = 431;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Print:
				_localctx = new FuncionImprimirContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 388;
				Match(Print);
				State = 389;
				Match(LPAREN);
				State = 392;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case Append:
				case Len:
				case Cap:
				case LPAREN:
				case Not:
				case Mas:
				case Menos:
				case DisyuncionExclusiva:
				case Identifier:
				case Int_lit:
				case Float_Lit:
				case Raw_String_Lit:
				case Interpreted_String_Lit:
				case Rune_Lit:
					{
					State = 390;
					expressionList();
					}
					break;
				case RPAREN:
					{
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 394;
				Match(RPAREN);
				State = 395;
				Match(SEMICOLON);
				}
				break;
			case PrintLn:
				_localctx = new FuncionImprimirLnContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 396;
				Match(PrintLn);
				State = 397;
				Match(LPAREN);
				State = 400;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,26,Context) ) {
				case 1:
					{
					State = 398;
					expressionList();
					}
					break;
				case 2:
					{
					State = 399;
					Match(Raw_String_Lit);
					}
					break;
				}
				State = 402;
				Match(RPAREN);
				State = 403;
				Match(SEMICOLON);
				}
				break;
			case Return:
				_localctx = new FuncionRetornarContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 404;
				Match(Return);
				State = 407;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case Append:
				case Len:
				case Cap:
				case LPAREN:
				case Not:
				case Mas:
				case Menos:
				case DisyuncionExclusiva:
				case Identifier:
				case Int_lit:
				case Float_Lit:
				case Raw_String_Lit:
				case Interpreted_String_Lit:
				case Rune_Lit:
					{
					State = 405;
					expression(0);
					}
					break;
				case SEMICOLON:
					{
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 409;
				Match(SEMICOLON);
				}
				break;
			case Break:
				_localctx = new FuncionBreakContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 410;
				Match(Break);
				State = 411;
				Match(SEMICOLON);
				}
				break;
			case Continue:
				_localctx = new FuncionContinuarContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 412;
				Match(Continue);
				State = 413;
				Match(SEMICOLON);
				}
				break;
			case Append:
			case Len:
			case Cap:
			case LPAREN:
			case SEMICOLON:
			case Not:
			case Mas:
			case Menos:
			case DisyuncionExclusiva:
			case Identifier:
			case Int_lit:
			case Float_Lit:
			case Raw_String_Lit:
			case Interpreted_String_Lit:
			case Rune_Lit:
				_localctx = new ExpresionSimpleContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 414;
				simpleStatement();
				State = 415;
				Match(SEMICOLON);
				}
				break;
			case LlaveD:
				_localctx = new FuncionBlockContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 417;
				block();
				State = 418;
				Match(SEMICOLON);
				}
				break;
			case Switch:
				_localctx = new FuncionSwitchContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 420;
				@switch();
				State = 421;
				Match(SEMICOLON);
				}
				break;
			case If:
				_localctx = new FuncionIfContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 423;
				ifStatement();
				State = 424;
				Match(SEMICOLON);
				}
				break;
			case For:
				_localctx = new FuncionLoopContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 426;
				loop();
				State = 427;
				Match(SEMICOLON);
				}
				break;
			case Type:
				_localctx = new DeclararTiposContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 429;
				typeDecl();
				}
				break;
			case Var:
				_localctx = new DeclararVariablesContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 430;
				variableDecl();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleStatementContext : ParserRuleContext {
		public SimpleStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleStatement; } }
	 
		public SimpleStatementContext() { }
		public virtual void CopyFrom(SimpleStatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SentenciaDefinirContext : SimpleStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext[] expressionList() {
			return GetRuleContexts<ExpressionListContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList(int i) {
			return GetRuleContext<ExpressionListContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Definir() { return GetToken(MiniGoParser.Definir, 0); }
		public SentenciaDefinirContext(SimpleStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSentenciaDefinir(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FuncionEpsilon1Context : SimpleStatementContext {
		public FuncionEpsilon1Context(SimpleStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncionEpsilon1(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DecrementoIncrementoContext : SimpleStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Incremento() { return GetToken(MiniGoParser.Incremento, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Decremento() { return GetToken(MiniGoParser.Decremento, 0); }
		public DecrementoIncrementoContext(SimpleStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDecrementoIncremento(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DeclararAsignacionContext : SimpleStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentStatementContext assignmentStatement() {
			return GetRuleContext<AssignmentStatementContext>(0);
		}
		public DeclararAsignacionContext(SimpleStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclararAsignacion(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SimpleStatementContext simpleStatement() {
		SimpleStatementContext _localctx = new SimpleStatementContext(Context, State);
		EnterRule(_localctx, 64, RULE_simpleStatement);
		try {
			State = 445;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				_localctx = new FuncionEpsilon1Context(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				}
				break;
			case 2:
				_localctx = new DecrementoIncrementoContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 434;
				expression(0);
				State = 438;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case Incremento:
					{
					State = 435;
					Match(Incremento);
					}
					break;
				case Decremento:
					{
					State = 436;
					Match(Decremento);
					}
					break;
				case SEMICOLON:
				case LlaveD:
					{
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 3:
				_localctx = new DeclararAsignacionContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 440;
				assignmentStatement();
				}
				break;
			case 4:
				_localctx = new SentenciaDefinirContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 441;
				expressionList();
				State = 442;
				Match(Definir);
				State = 443;
				expressionList();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignmentStatementContext : ParserRuleContext {
		public AssignmentStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignmentStatement; } }
	 
		public AssignmentStatementContext() { }
		public virtual void CopyFrom(AssignmentStatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class UndecimaAsignacionContext : AssignmentStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RestarPorcentaje() { return GetToken(MiniGoParser.RestarPorcentaje, 0); }
		public UndecimaAsignacionContext(AssignmentStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUndecimaAsignacion(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TercerAsignacionContext : AssignmentStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AndValores() { return GetToken(MiniGoParser.AndValores, 0); }
		public TercerAsignacionContext(AssignmentStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTercerAsignacion(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SextaAsignacionContext : AssignmentStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MultiIzquierda() { return GetToken(MiniGoParser.MultiIzquierda, 0); }
		public SextaAsignacionContext(AssignmentStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSextaAsignacion(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SegundaAsignacionContext : AssignmentStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SumaIzquierda() { return GetToken(MiniGoParser.SumaIzquierda, 0); }
		public SegundaAsignacionContext(AssignmentStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSegundaAsignacion(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OctavaAsignacionContext : AssignmentStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AsignCorrimientoIzquierda() { return GetToken(MiniGoParser.AsignCorrimientoIzquierda, 0); }
		public OctavaAsignacionContext(AssignmentStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOctavaAsignacion(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DecimaAsignacionContext : AssignmentStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AndExclusivo() { return GetToken(MiniGoParser.AndExclusivo, 0); }
		public DecimaAsignacionContext(AssignmentStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDecimaAsignacion(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DuodecimaAsignacionContext : AssignmentStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DivisionIzquierda() { return GetToken(MiniGoParser.DivisionIzquierda, 0); }
		public DuodecimaAsignacionContext(AssignmentStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDuodecimaAsignacion(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SetimaAsignacionContext : AssignmentStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AsignacionExclusiva() { return GetToken(MiniGoParser.AsignacionExclusiva, 0); }
		public SetimaAsignacionContext(AssignmentStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetimaAsignacion(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PrimerAsignacionContext : AssignmentStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext[] expressionList() {
			return GetRuleContexts<ExpressionListContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList(int i) {
			return GetRuleContext<ExpressionListContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Asign() { return GetToken(MiniGoParser.Asign, 0); }
		public PrimerAsignacionContext(AssignmentStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimerAsignacion(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CuartaAsignacionContext : AssignmentStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RestaIzquierda() { return GetToken(MiniGoParser.RestaIzquierda, 0); }
		public CuartaAsignacionContext(AssignmentStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCuartaAsignacion(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NovenaAsignacionContext : AssignmentStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AsignCorrimientoDerecha() { return GetToken(MiniGoParser.AsignCorrimientoDerecha, 0); }
		public NovenaAsignacionContext(AssignmentStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNovenaAsignacion(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class QuintaAsignacionContext : AssignmentStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OrValores() { return GetToken(MiniGoParser.OrValores, 0); }
		public QuintaAsignacionContext(AssignmentStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuintaAsignacion(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentStatementContext assignmentStatement() {
		AssignmentStatementContext _localctx = new AssignmentStatementContext(Context, State);
		EnterRule(_localctx, 66, RULE_assignmentStatement);
		try {
			State = 495;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,31,Context) ) {
			case 1:
				_localctx = new PrimerAsignacionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 447;
				expressionList();
				State = 448;
				Match(Asign);
				State = 449;
				expressionList();
				}
				break;
			case 2:
				_localctx = new SegundaAsignacionContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 451;
				expression(0);
				State = 452;
				Match(SumaIzquierda);
				State = 453;
				expression(0);
				}
				break;
			case 3:
				_localctx = new TercerAsignacionContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 455;
				expression(0);
				State = 456;
				Match(AndValores);
				State = 457;
				expression(0);
				}
				break;
			case 4:
				_localctx = new CuartaAsignacionContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 459;
				expression(0);
				State = 460;
				Match(RestaIzquierda);
				State = 461;
				expression(0);
				}
				break;
			case 5:
				_localctx = new QuintaAsignacionContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 463;
				expression(0);
				State = 464;
				Match(OrValores);
				State = 465;
				expression(0);
				}
				break;
			case 6:
				_localctx = new SextaAsignacionContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 467;
				expression(0);
				State = 468;
				Match(MultiIzquierda);
				State = 469;
				expression(0);
				}
				break;
			case 7:
				_localctx = new SetimaAsignacionContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 471;
				expression(0);
				State = 472;
				Match(AsignacionExclusiva);
				State = 473;
				expression(0);
				}
				break;
			case 8:
				_localctx = new OctavaAsignacionContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 475;
				expression(0);
				State = 476;
				Match(AsignCorrimientoIzquierda);
				State = 477;
				expression(0);
				}
				break;
			case 9:
				_localctx = new NovenaAsignacionContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 479;
				expression(0);
				State = 480;
				Match(AsignCorrimientoDerecha);
				State = 481;
				expression(0);
				}
				break;
			case 10:
				_localctx = new DecimaAsignacionContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 483;
				expression(0);
				State = 484;
				Match(AndExclusivo);
				State = 485;
				expression(0);
				}
				break;
			case 11:
				_localctx = new UndecimaAsignacionContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 487;
				expression(0);
				State = 488;
				Match(RestarPorcentaje);
				State = 489;
				expression(0);
				}
				break;
			case 12:
				_localctx = new DuodecimaAsignacionContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 491;
				expression(0);
				State = 492;
				Match(DivisionIzquierda);
				State = 493;
				expression(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfStatementContext : ParserRuleContext {
		public IfStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifStatement; } }
	 
		public IfStatementContext() { }
		public virtual void CopyFrom(IfStatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class TercerIfContext : IfStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode If() { return GetToken(MiniGoParser.If, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext[] block() {
			return GetRuleContexts<BlockContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block(int i) {
			return GetRuleContext<BlockContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Else() { return GetToken(MiniGoParser.Else, 0); }
		public TercerIfContext(IfStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTercerIf(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PrimerIfContext : IfStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode If() { return GetToken(MiniGoParser.If, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public PrimerIfContext(IfStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimerIf(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SextoIfContext : IfStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode If() { return GetToken(MiniGoParser.If, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleStatementContext simpleStatement() {
			return GetRuleContext<SimpleStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext[] block() {
			return GetRuleContexts<BlockContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block(int i) {
			return GetRuleContext<BlockContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Else() { return GetToken(MiniGoParser.Else, 0); }
		public SextoIfContext(IfStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSextoIf(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CuartoIfContext : IfStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode If() { return GetToken(MiniGoParser.If, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleStatementContext simpleStatement() {
			return GetRuleContext<SimpleStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public CuartoIfContext(IfStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCuartoIf(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SegundoIfContext : IfStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode If() { return GetToken(MiniGoParser.If, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Else() { return GetToken(MiniGoParser.Else, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IfStatementContext ifStatement() {
			return GetRuleContext<IfStatementContext>(0);
		}
		public SegundoIfContext(IfStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSegundoIf(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class QuintoIfContext : IfStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode If() { return GetToken(MiniGoParser.If, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleStatementContext simpleStatement() {
			return GetRuleContext<SimpleStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Else() { return GetToken(MiniGoParser.Else, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IfStatementContext ifStatement() {
			return GetRuleContext<IfStatementContext>(0);
		}
		public QuintoIfContext(IfStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuintoIf(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfStatementContext ifStatement() {
		IfStatementContext _localctx = new IfStatementContext(Context, State);
		EnterRule(_localctx, 68, RULE_ifStatement);
		try {
			State = 535;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,32,Context) ) {
			case 1:
				_localctx = new PrimerIfContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 497;
				Match(If);
				State = 498;
				expression(0);
				State = 499;
				block();
				}
				break;
			case 2:
				_localctx = new SegundoIfContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 501;
				Match(If);
				State = 502;
				expression(0);
				State = 503;
				block();
				State = 504;
				Match(Else);
				State = 505;
				ifStatement();
				}
				break;
			case 3:
				_localctx = new TercerIfContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 507;
				Match(If);
				State = 508;
				expression(0);
				State = 509;
				block();
				State = 510;
				Match(Else);
				State = 511;
				block();
				}
				break;
			case 4:
				_localctx = new CuartoIfContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 513;
				Match(If);
				State = 514;
				simpleStatement();
				State = 515;
				Match(SEMICOLON);
				State = 516;
				expression(0);
				State = 517;
				block();
				}
				break;
			case 5:
				_localctx = new QuintoIfContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 519;
				Match(If);
				State = 520;
				simpleStatement();
				State = 521;
				Match(SEMICOLON);
				State = 522;
				expression(0);
				State = 523;
				block();
				State = 524;
				Match(Else);
				State = 525;
				ifStatement();
				}
				break;
			case 6:
				_localctx = new SextoIfContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 527;
				Match(If);
				State = 528;
				simpleStatement();
				State = 529;
				Match(SEMICOLON);
				State = 530;
				expression(0);
				State = 531;
				block();
				State = 532;
				Match(Else);
				State = 533;
				block();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopContext : ParserRuleContext {
		public LoopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loop; } }
	 
		public LoopContext() { }
		public virtual void CopyFrom(LoopContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class CuartoForContext : LoopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode For() { return GetToken(MiniGoParser.For, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleStatementContext[] simpleStatement() {
			return GetRuleContexts<SimpleStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleStatementContext simpleStatement(int i) {
			return GetRuleContext<SimpleStatementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] SEMICOLON() { return GetTokens(MiniGoParser.SEMICOLON); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON(int i) {
			return GetToken(MiniGoParser.SEMICOLON, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public CuartoForContext(LoopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCuartoFor(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SegundoForContext : LoopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode For() { return GetToken(MiniGoParser.For, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public SegundoForContext(LoopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSegundoFor(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TercerForContext : LoopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode For() { return GetToken(MiniGoParser.For, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleStatementContext[] simpleStatement() {
			return GetRuleContexts<SimpleStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleStatementContext simpleStatement(int i) {
			return GetRuleContext<SimpleStatementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] SEMICOLON() { return GetTokens(MiniGoParser.SEMICOLON); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON(int i) {
			return GetToken(MiniGoParser.SEMICOLON, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public TercerForContext(LoopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTercerFor(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PrimerForContext : LoopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode For() { return GetToken(MiniGoParser.For, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public PrimerForContext(LoopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimerFor(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoopContext loop() {
		LoopContext _localctx = new LoopContext(Context, State);
		EnterRule(_localctx, 70, RULE_loop);
		try {
			State = 558;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,33,Context) ) {
			case 1:
				_localctx = new PrimerForContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 537;
				Match(For);
				State = 538;
				block();
				}
				break;
			case 2:
				_localctx = new SegundoForContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 539;
				Match(For);
				State = 540;
				expression(0);
				State = 541;
				block();
				}
				break;
			case 3:
				_localctx = new TercerForContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 543;
				Match(For);
				State = 544;
				simpleStatement();
				State = 545;
				Match(SEMICOLON);
				State = 546;
				expression(0);
				State = 547;
				Match(SEMICOLON);
				State = 548;
				simpleStatement();
				State = 549;
				block();
				}
				break;
			case 4:
				_localctx = new CuartoForContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 551;
				Match(For);
				State = 552;
				simpleStatement();
				State = 553;
				Match(SEMICOLON);
				State = 554;
				Match(SEMICOLON);
				State = 555;
				simpleStatement();
				State = 556;
				block();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SwitchContext : ParserRuleContext {
		public SwitchContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_switch; } }
	 
		public SwitchContext() { }
		public virtual void CopyFrom(SwitchContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class CuartoSwitchContext : SwitchContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Switch() { return GetToken(MiniGoParser.Switch, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LlaveD() { return GetToken(MiniGoParser.LlaveD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionCaseClauseListContext expressionCaseClauseList() {
			return GetRuleContext<ExpressionCaseClauseListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LlaveI() { return GetToken(MiniGoParser.LlaveI, 0); }
		public CuartoSwitchContext(SwitchContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCuartoSwitch(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SegundoSwitchContext : SwitchContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Switch() { return GetToken(MiniGoParser.Switch, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LlaveD() { return GetToken(MiniGoParser.LlaveD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionCaseClauseListContext expressionCaseClauseList() {
			return GetRuleContext<ExpressionCaseClauseListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LlaveI() { return GetToken(MiniGoParser.LlaveI, 0); }
		public SegundoSwitchContext(SwitchContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSegundoSwitch(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PrimerSwitchContext : SwitchContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Switch() { return GetToken(MiniGoParser.Switch, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleStatementContext simpleStatement() {
			return GetRuleContext<SimpleStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LlaveD() { return GetToken(MiniGoParser.LlaveD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionCaseClauseListContext expressionCaseClauseList() {
			return GetRuleContext<ExpressionCaseClauseListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LlaveI() { return GetToken(MiniGoParser.LlaveI, 0); }
		public PrimerSwitchContext(SwitchContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimerSwitch(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TecerSwitchContext : SwitchContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Switch() { return GetToken(MiniGoParser.Switch, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleStatementContext simpleStatement() {
			return GetRuleContext<SimpleStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(MiniGoParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LlaveD() { return GetToken(MiniGoParser.LlaveD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionCaseClauseListContext expressionCaseClauseList() {
			return GetRuleContext<ExpressionCaseClauseListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LlaveI() { return GetToken(MiniGoParser.LlaveI, 0); }
		public TecerSwitchContext(SwitchContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTecerSwitch(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SwitchContext @switch() {
		SwitchContext _localctx = new SwitchContext(Context, State);
		EnterRule(_localctx, 72, RULE_switch);
		try {
			State = 586;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,34,Context) ) {
			case 1:
				_localctx = new PrimerSwitchContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 560;
				Match(Switch);
				State = 561;
				simpleStatement();
				State = 562;
				Match(SEMICOLON);
				State = 563;
				expression(0);
				State = 564;
				Match(LlaveD);
				State = 565;
				expressionCaseClauseList();
				State = 566;
				Match(LlaveI);
				}
				break;
			case 2:
				_localctx = new SegundoSwitchContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 568;
				Match(Switch);
				State = 569;
				expression(0);
				State = 570;
				Match(LlaveD);
				State = 571;
				expressionCaseClauseList();
				State = 572;
				Match(LlaveI);
				}
				break;
			case 3:
				_localctx = new TecerSwitchContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 574;
				Match(Switch);
				State = 575;
				simpleStatement();
				State = 576;
				Match(SEMICOLON);
				State = 577;
				Match(LlaveD);
				State = 578;
				expressionCaseClauseList();
				State = 579;
				Match(LlaveI);
				}
				break;
			case 4:
				_localctx = new CuartoSwitchContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 581;
				Match(Switch);
				State = 582;
				Match(LlaveD);
				State = 583;
				expressionCaseClauseList();
				State = 584;
				Match(LlaveI);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionCaseClauseListContext : ParserRuleContext {
		public ExpressionCaseClauseListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionCaseClauseList; } }
	 
		public ExpressionCaseClauseListContext() { }
		public virtual void CopyFrom(ExpressionCaseClauseListContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class FuncionEpsilonContext : ExpressionCaseClauseListContext {
		public FuncionEpsilonContext(ExpressionCaseClauseListContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncionEpsilon(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpresionCasoClausulaContext : ExpressionCaseClauseListContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionCaseClauseContext expressionCaseClause() {
			return GetRuleContext<ExpressionCaseClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionCaseClauseListContext expressionCaseClauseList() {
			return GetRuleContext<ExpressionCaseClauseListContext>(0);
		}
		public ExpresionCasoClausulaContext(ExpressionCaseClauseListContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpresionCasoClausula(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionCaseClauseListContext expressionCaseClauseList() {
		ExpressionCaseClauseListContext _localctx = new ExpressionCaseClauseListContext(Context, State);
		EnterRule(_localctx, 74, RULE_expressionCaseClauseList);
		try {
			State = 592;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LlaveI:
				_localctx = new FuncionEpsilonContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				}
				break;
			case Case:
			case Default:
				_localctx = new ExpresionCasoClausulaContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 589;
				expressionCaseClause();
				State = 590;
				expressionCaseClauseList();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionCaseClauseContext : ParserRuleContext {
		public ExpressionCaseClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionCaseClause; } }
	 
		public ExpressionCaseClauseContext() { }
		public virtual void CopyFrom(ExpressionCaseClauseContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ExpresionSwitchContext : ExpressionCaseClauseContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionSwitchCaseContext expressionSwitchCase() {
			return GetRuleContext<ExpressionSwitchCaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Puntos() { return GetToken(MiniGoParser.Puntos, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementListContext statementList() {
			return GetRuleContext<StatementListContext>(0);
		}
		public ExpresionSwitchContext(ExpressionCaseClauseContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpresionSwitch(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionCaseClauseContext expressionCaseClause() {
		ExpressionCaseClauseContext _localctx = new ExpressionCaseClauseContext(Context, State);
		EnterRule(_localctx, 76, RULE_expressionCaseClause);
		try {
			_localctx = new ExpresionSwitchContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 594;
			expressionSwitchCase();
			State = 595;
			Match(Puntos);
			State = 596;
			statementList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionSwitchCaseContext : ParserRuleContext {
		public ExpressionSwitchCaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionSwitchCase; } }
	 
		public ExpressionSwitchCaseContext() { }
		public virtual void CopyFrom(ExpressionSwitchCaseContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ExpresionCaseContext : ExpressionSwitchCaseContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Case() { return GetToken(MiniGoParser.Case, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public ExpresionCaseContext(ExpressionSwitchCaseContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpresionCase(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpresionDefaultContext : ExpressionSwitchCaseContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Default() { return GetToken(MiniGoParser.Default, 0); }
		public ExpresionDefaultContext(ExpressionSwitchCaseContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMiniGoParserVisitor<TResult> typedVisitor = visitor as IMiniGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpresionDefault(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionSwitchCaseContext expressionSwitchCase() {
		ExpressionSwitchCaseContext _localctx = new ExpressionSwitchCaseContext(Context, State);
		EnterRule(_localctx, 78, RULE_expressionSwitchCase);
		try {
			State = 601;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Case:
				_localctx = new ExpresionCaseContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 598;
				Match(Case);
				State = 599;
				expressionList();
				}
				break;
			case Default:
				_localctx = new ExpresionDefaultContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 600;
				Match(Default);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 18: return expression_sempred((ExpressionContext)_localctx, predIndex);
		case 20: return primaryExpression_sempred((PrimaryExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 23);
		case 1: return Precpred(Context, 22);
		case 2: return Precpred(Context, 21);
		case 3: return Precpred(Context, 20);
		case 4: return Precpred(Context, 19);
		case 5: return Precpred(Context, 18);
		case 6: return Precpred(Context, 17);
		case 7: return Precpred(Context, 16);
		case 8: return Precpred(Context, 15);
		case 9: return Precpred(Context, 14);
		case 10: return Precpred(Context, 13);
		case 11: return Precpred(Context, 12);
		case 12: return Precpred(Context, 11);
		case 13: return Precpred(Context, 10);
		case 14: return Precpred(Context, 9);
		case 15: return Precpred(Context, 8);
		case 16: return Precpred(Context, 7);
		case 17: return Precpred(Context, 6);
		case 18: return Precpred(Context, 5);
		}
		return true;
	}
	private bool primaryExpression_sempred(PrimaryExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 19: return Precpred(Context, 6);
		case 20: return Precpred(Context, 5);
		case 21: return Precpred(Context, 4);
		}
		return true;
	}

	private static char[] _serializedATN = {
		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786', 
		'\x5964', '\x3', '\x65', '\x25E', '\x4', '\x2', '\t', '\x2', '\x4', '\x3', 
		'\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', '\x4', 
		'\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', '\b', 
		'\x4', '\t', '\t', '\t', '\x4', '\n', '\t', '\n', '\x4', '\v', '\t', '\v', 
		'\x4', '\f', '\t', '\f', '\x4', '\r', '\t', '\r', '\x4', '\xE', '\t', 
		'\xE', '\x4', '\xF', '\t', '\xF', '\x4', '\x10', '\t', '\x10', '\x4', 
		'\x11', '\t', '\x11', '\x4', '\x12', '\t', '\x12', '\x4', '\x13', '\t', 
		'\x13', '\x4', '\x14', '\t', '\x14', '\x4', '\x15', '\t', '\x15', '\x4', 
		'\x16', '\t', '\x16', '\x4', '\x17', '\t', '\x17', '\x4', '\x18', '\t', 
		'\x18', '\x4', '\x19', '\t', '\x19', '\x4', '\x1A', '\t', '\x1A', '\x4', 
		'\x1B', '\t', '\x1B', '\x4', '\x1C', '\t', '\x1C', '\x4', '\x1D', '\t', 
		'\x1D', '\x4', '\x1E', '\t', '\x1E', '\x4', '\x1F', '\t', '\x1F', '\x4', 
		' ', '\t', ' ', '\x4', '!', '\t', '!', '\x4', '\"', '\t', '\"', '\x4', 
		'#', '\t', '#', '\x4', '$', '\t', '$', '\x4', '%', '\t', '%', '\x4', '&', 
		'\t', '&', '\x4', '\'', '\t', '\'', '\x4', '(', '\t', '(', '\x4', ')', 
		'\t', ')', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\a', '\x3', '[', '\n', 
		'\x3', '\f', '\x3', '\xE', '\x3', '^', '\v', '\x3', '\x3', '\x4', '\x3', 
		'\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', 
		'\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', 
		'\x4', '\x3', '\x4', '\x3', '\x4', '\x5', '\x4', 'n', '\n', '\x4', '\x3', 
		'\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\a', '\x5', 
		'u', '\n', '\x5', '\f', '\x5', '\xE', '\x5', 'x', '\v', '\x5', '\x3', 
		'\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', 
		'\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x5', 
		'\x6', '\x84', '\n', '\x6', '\x3', '\a', '\x3', '\a', '\x3', '\a', '\x3', 
		'\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', 
		'\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', 
		'\b', '\x3', '\b', '\x3', '\b', '\x5', '\b', '\x97', '\n', '\b', '\x3', 
		'\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\a', '\t', 
		'\x9E', '\n', '\t', '\f', '\t', '\xE', '\t', '\xA1', '\v', '\t', '\x3', 
		'\n', '\x3', '\n', '\x3', '\n', '\x3', '\v', '\x3', '\v', '\x3', '\v', 
		'\x3', '\v', '\x3', '\f', '\x3', '\f', '\x3', '\f', '\x3', '\f', '\x3', 
		'\f', '\x5', '\f', '\xAF', '\n', '\f', '\x3', '\f', '\x3', '\f', '\x3', 
		'\f', '\x5', '\f', '\xB4', '\n', '\f', '\x3', '\r', '\x3', '\r', '\x3', 
		'\r', '\a', '\r', '\xB9', '\n', '\r', '\f', '\r', '\xE', '\r', '\xBC', 
		'\v', '\r', '\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x3', 
		'\xE', '\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x5', '\xE', '\xC6', 
		'\n', '\xE', '\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x3', 
		'\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', 
		'\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x5', '\x11', '\xD5', 
		'\n', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x12', '\x3', '\x12', 
		'\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\a', '\x12', '\xDE', '\n', 
		'\x12', '\f', '\x12', '\xE', '\x12', '\xE1', '\v', '\x12', '\x3', '\x13', 
		'\x3', '\x13', '\x3', '\x13', '\a', '\x13', '\xE6', '\n', '\x13', '\f', 
		'\x13', '\xE', '\x13', '\xE9', '\v', '\x13', '\x3', '\x14', '\x3', '\x14', 
		'\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', 
		'\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x5', '\x14', '\xF5', '\n', 
		'\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', 
		'\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', 
		'\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', 
		'\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', 
		'\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', 
		'\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', 
		'\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', 
		'\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', 
		'\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', 
		'\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', 
		'\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', 
		'\x14', '\x3', '\x14', '\x3', '\x14', '\a', '\x14', '\x130', '\n', '\x14', 
		'\f', '\x14', '\xE', '\x14', '\x133', '\v', '\x14', '\x3', '\x15', '\x3', 
		'\x15', '\x3', '\x15', '\a', '\x15', '\x138', '\n', '\x15', '\f', '\x15', 
		'\xE', '\x15', '\x13B', '\v', '\x15', '\x3', '\x16', '\x3', '\x16', '\x3', 
		'\x16', '\x3', '\x16', '\x3', '\x16', '\x5', '\x16', '\x142', '\n', '\x16', 
		'\x3', '\x16', '\x3', '\x16', '\x3', '\x16', '\x3', '\x16', '\x3', '\x16', 
		'\x3', '\x16', '\a', '\x16', '\x14A', '\n', '\x16', '\f', '\x16', '\xE', 
		'\x16', '\x14D', '\v', '\x16', '\x3', '\x17', '\x3', '\x17', '\x3', '\x17', 
		'\x3', '\x17', '\x3', '\x17', '\x3', '\x17', '\x5', '\x17', '\x155', '\n', 
		'\x17', '\x3', '\x18', '\x3', '\x18', '\x3', '\x18', '\x3', '\x18', '\x3', 
		'\x18', '\x5', '\x18', '\x15C', '\n', '\x18', '\x3', '\x19', '\x3', '\x19', 
		'\x3', '\x19', '\x3', '\x19', '\x3', '\x1A', '\x3', '\x1A', '\x3', '\x1A', 
		'\x5', '\x1A', '\x165', '\n', '\x1A', '\x3', '\x1A', '\x3', '\x1A', '\x3', 
		'\x1B', '\x3', '\x1B', '\x3', '\x1B', '\x3', '\x1C', '\x3', '\x1C', '\x3', 
		'\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3', 
		'\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', 
		'\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', 
		'\x1F', '\a', '\x1F', '\x17E', '\n', '\x1F', '\f', '\x1F', '\xE', '\x1F', 
		'\x181', '\v', '\x1F', '\x3', ' ', '\x3', ' ', '\x3', ' ', '\x3', ' ', 
		'\x3', '!', '\x3', '!', '\x3', '!', '\x3', '!', '\x5', '!', '\x18B', '\n', 
		'!', '\x3', '!', '\x3', '!', '\x3', '!', '\x3', '!', '\x3', '!', '\x3', 
		'!', '\x5', '!', '\x193', '\n', '!', '\x3', '!', '\x3', '!', '\x3', '!', 
		'\x3', '!', '\x3', '!', '\x5', '!', '\x19A', '\n', '!', '\x3', '!', '\x3', 
		'!', '\x3', '!', '\x3', '!', '\x3', '!', '\x3', '!', '\x3', '!', '\x3', 
		'!', '\x3', '!', '\x3', '!', '\x3', '!', '\x3', '!', '\x3', '!', '\x3', 
		'!', '\x3', '!', '\x3', '!', '\x3', '!', '\x3', '!', '\x3', '!', '\x3', 
		'!', '\x3', '!', '\x3', '!', '\x5', '!', '\x1B2', '\n', '!', '\x3', '\"', 
		'\x3', '\"', '\x3', '\"', '\x3', '\"', '\x3', '\"', '\x5', '\"', '\x1B9', 
		'\n', '\"', '\x3', '\"', '\x3', '\"', '\x3', '\"', '\x3', '\"', '\x3', 
		'\"', '\x5', '\"', '\x1C0', '\n', '\"', '\x3', '#', '\x3', '#', '\x3', 
		'#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', 
		'#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', 
		'#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', 
		'#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', 
		'#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', 
		'#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', 
		'#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', 
		'#', '\x3', '#', '\x3', '#', '\x3', '#', '\x5', '#', '\x1F2', '\n', '#', 
		'\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', 
		'\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', 
		'\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', 
		'\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', 
		'\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', 
		'\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', 
		'\x3', '$', '\x3', '$', '\x5', '$', '\x21A', '\n', '$', '\x3', '%', '\x3', 
		'%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', 
		'%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', 
		'%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', 
		'%', '\x3', '%', '\x5', '%', '\x231', '\n', '%', '\x3', '&', '\x3', '&', 
		'\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', 
		'\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', 
		'\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', 
		'\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', 
		'\x5', '&', '\x24D', '\n', '&', '\x3', '\'', '\x3', '\'', '\x3', '\'', 
		'\x3', '\'', '\x5', '\'', '\x253', '\n', '\'', '\x3', '(', '\x3', '(', 
		'\x3', '(', '\x3', '(', '\x3', ')', '\x3', ')', '\x3', ')', '\x5', ')', 
		'\x25C', '\n', ')', '\x3', ')', '\x2', '\x4', '&', '*', '*', '\x2', '\x4', 
		'\x6', '\b', '\n', '\f', '\xE', '\x10', '\x12', '\x14', '\x16', '\x18', 
		'\x1A', '\x1C', '\x1E', ' ', '\"', '$', '&', '(', '*', ',', '.', '\x30', 
		'\x32', '\x34', '\x36', '\x38', ':', '<', '>', '@', '\x42', '\x44', '\x46', 
		'H', 'J', 'L', 'N', 'P', '\x2', '\x2', '\x2', '\x29B', '\x2', 'R', '\x3', 
		'\x2', '\x2', '\x2', '\x4', '\\', '\x3', '\x2', '\x2', '\x2', '\x6', 'm', 
		'\x3', '\x2', '\x2', '\x2', '\b', 'o', '\x3', '\x2', '\x2', '\x2', '\n', 
		'\x83', '\x3', '\x2', '\x2', '\x2', '\f', '\x85', '\x3', '\x2', '\x2', 
		'\x2', '\xE', '\x96', '\x3', '\x2', '\x2', '\x2', '\x10', '\x98', '\x3', 
		'\x2', '\x2', '\x2', '\x12', '\xA2', '\x3', '\x2', '\x2', '\x2', '\x14', 
		'\xA5', '\x3', '\x2', '\x2', '\x2', '\x16', '\xA9', '\x3', '\x2', '\x2', 
		'\x2', '\x18', '\xB5', '\x3', '\x2', '\x2', '\x2', '\x1A', '\xC5', '\x3', 
		'\x2', '\x2', '\x2', '\x1C', '\xC7', '\x3', '\x2', '\x2', '\x2', '\x1E', 
		'\xCB', '\x3', '\x2', '\x2', '\x2', ' ', '\xD0', '\x3', '\x2', '\x2', 
		'\x2', '\"', '\xD8', '\x3', '\x2', '\x2', '\x2', '$', '\xE2', '\x3', '\x2', 
		'\x2', '\x2', '&', '\xF4', '\x3', '\x2', '\x2', '\x2', '(', '\x134', '\x3', 
		'\x2', '\x2', '\x2', '*', '\x141', '\x3', '\x2', '\x2', '\x2', ',', '\x154', 
		'\x3', '\x2', '\x2', '\x2', '.', '\x15B', '\x3', '\x2', '\x2', '\x2', 
		'\x30', '\x15D', '\x3', '\x2', '\x2', '\x2', '\x32', '\x161', '\x3', '\x2', 
		'\x2', '\x2', '\x34', '\x168', '\x3', '\x2', '\x2', '\x2', '\x36', '\x16B', 
		'\x3', '\x2', '\x2', '\x2', '\x38', '\x172', '\x3', '\x2', '\x2', '\x2', 
		':', '\x177', '\x3', '\x2', '\x2', '\x2', '<', '\x17F', '\x3', '\x2', 
		'\x2', '\x2', '>', '\x182', '\x3', '\x2', '\x2', '\x2', '@', '\x1B1', 
		'\x3', '\x2', '\x2', '\x2', '\x42', '\x1BF', '\x3', '\x2', '\x2', '\x2', 
		'\x44', '\x1F1', '\x3', '\x2', '\x2', '\x2', '\x46', '\x219', '\x3', '\x2', 
		'\x2', '\x2', 'H', '\x230', '\x3', '\x2', '\x2', '\x2', 'J', '\x24C', 
		'\x3', '\x2', '\x2', '\x2', 'L', '\x252', '\x3', '\x2', '\x2', '\x2', 
		'N', '\x254', '\x3', '\x2', '\x2', '\x2', 'P', '\x25B', '\x3', '\x2', 
		'\x2', '\x2', 'R', 'S', '\a', '\x3', '\x2', '\x2', 'S', 'T', '\a', 'I', 
		'\x2', '\x2', 'T', 'U', '\a', '\x1A', '\x2', '\x2', 'U', 'V', '\x5', '\x4', 
		'\x3', '\x2', 'V', '\x3', '\x3', '\x2', '\x2', '\x2', 'W', '[', '\x5', 
		'\x6', '\x4', '\x2', 'X', '[', '\x5', '\xE', '\b', '\x2', 'Y', '[', '\x5', 
		'\x14', '\v', '\x2', 'Z', 'W', '\x3', '\x2', '\x2', '\x2', 'Z', 'X', '\x3', 
		'\x2', '\x2', '\x2', 'Z', 'Y', '\x3', '\x2', '\x2', '\x2', '[', '^', '\x3', 
		'\x2', '\x2', '\x2', '\\', 'Z', '\x3', '\x2', '\x2', '\x2', '\\', ']', 
		'\x3', '\x2', '\x2', '\x2', ']', '\x5', '\x3', '\x2', '\x2', '\x2', '^', 
		'\\', '\x3', '\x2', '\x2', '\x2', '_', '`', '\a', '\x5', '\x2', '\x2', 
		'`', '\x61', '\x5', '\n', '\x6', '\x2', '\x61', '\x62', '\a', '\x1A', 
		'\x2', '\x2', '\x62', 'n', '\x3', '\x2', '\x2', '\x2', '\x63', '\x64', 
		'\a', '\x5', '\x2', '\x2', '\x64', '\x65', '\a', '\x18', '\x2', '\x2', 
		'\x65', '\x66', '\x5', '\b', '\x5', '\x2', '\x66', 'g', '\a', '\x19', 
		'\x2', '\x2', 'g', 'h', '\a', '\x1A', '\x2', '\x2', 'h', 'n', '\x3', '\x2', 
		'\x2', '\x2', 'i', 'j', '\a', '\x5', '\x2', '\x2', 'j', 'k', '\a', '\x18', 
		'\x2', '\x2', 'k', 'l', '\a', '\x19', '\x2', '\x2', 'l', 'n', '\a', '\x1A', 
		'\x2', '\x2', 'm', '_', '\x3', '\x2', '\x2', '\x2', 'm', '\x63', '\x3', 
		'\x2', '\x2', '\x2', 'm', 'i', '\x3', '\x2', '\x2', '\x2', 'n', '\a', 
		'\x3', '\x2', '\x2', '\x2', 'o', 'p', '\x5', '\n', '\x6', '\x2', 'p', 
		'v', '\a', '\x1A', '\x2', '\x2', 'q', 'r', '\x5', '\n', '\x6', '\x2', 
		'r', 's', '\a', '\x1A', '\x2', '\x2', 's', 'u', '\x3', '\x2', '\x2', '\x2', 
		't', 'q', '\x3', '\x2', '\x2', '\x2', 'u', 'x', '\x3', '\x2', '\x2', '\x2', 
		'v', 't', '\x3', '\x2', '\x2', '\x2', 'v', 'w', '\x3', '\x2', '\x2', '\x2', 
		'w', '\t', '\x3', '\x2', '\x2', '\x2', 'x', 'v', '\x3', '\x2', '\x2', 
		'\x2', 'y', 'z', '\x5', '$', '\x13', '\x2', 'z', '{', '\x5', '\x1A', '\xE', 
		'\x2', '{', '|', '\a', '\x1B', '\x2', '\x2', '|', '}', '\x5', '(', '\x15', 
		'\x2', '}', '\x84', '\x3', '\x2', '\x2', '\x2', '~', '\x7F', '\x5', '$', 
		'\x13', '\x2', '\x7F', '\x80', '\a', '\x1B', '\x2', '\x2', '\x80', '\x81', 
		'\x5', '(', '\x15', '\x2', '\x81', '\x84', '\x3', '\x2', '\x2', '\x2', 
		'\x82', '\x84', '\x5', '\f', '\a', '\x2', '\x83', 'y', '\x3', '\x2', '\x2', 
		'\x2', '\x83', '~', '\x3', '\x2', '\x2', '\x2', '\x83', '\x82', '\x3', 
		'\x2', '\x2', '\x2', '\x84', '\v', '\x3', '\x2', '\x2', '\x2', '\x85', 
		'\x86', '\x5', '$', '\x13', '\x2', '\x86', '\x87', '\x5', '\x1A', '\xE', 
		'\x2', '\x87', '\r', '\x3', '\x2', '\x2', '\x2', '\x88', '\x89', '\a', 
		'\x6', '\x2', '\x2', '\x89', '\x8A', '\x5', '\x12', '\n', '\x2', '\x8A', 
		'\x8B', '\a', '\x1A', '\x2', '\x2', '\x8B', '\x97', '\x3', '\x2', '\x2', 
		'\x2', '\x8C', '\x8D', '\a', '\x6', '\x2', '\x2', '\x8D', '\x8E', '\a', 
		'\x18', '\x2', '\x2', '\x8E', '\x8F', '\x5', '\x10', '\t', '\x2', '\x8F', 
		'\x90', '\a', '\x19', '\x2', '\x2', '\x90', '\x91', '\a', '\x1A', '\x2', 
		'\x2', '\x91', '\x97', '\x3', '\x2', '\x2', '\x2', '\x92', '\x93', '\a', 
		'\x6', '\x2', '\x2', '\x93', '\x94', '\a', '\x18', '\x2', '\x2', '\x94', 
		'\x95', '\a', '\x19', '\x2', '\x2', '\x95', '\x97', '\a', '\x1A', '\x2', 
		'\x2', '\x96', '\x88', '\x3', '\x2', '\x2', '\x2', '\x96', '\x8C', '\x3', 
		'\x2', '\x2', '\x2', '\x96', '\x92', '\x3', '\x2', '\x2', '\x2', '\x97', 
		'\xF', '\x3', '\x2', '\x2', '\x2', '\x98', '\x99', '\x5', '\x12', '\n', 
		'\x2', '\x99', '\x9F', '\a', '\x1A', '\x2', '\x2', '\x9A', '\x9B', '\x5', 
		'\x12', '\n', '\x2', '\x9B', '\x9C', '\a', '\x1A', '\x2', '\x2', '\x9C', 
		'\x9E', '\x3', '\x2', '\x2', '\x2', '\x9D', '\x9A', '\x3', '\x2', '\x2', 
		'\x2', '\x9E', '\xA1', '\x3', '\x2', '\x2', '\x2', '\x9F', '\x9D', '\x3', 
		'\x2', '\x2', '\x2', '\x9F', '\xA0', '\x3', '\x2', '\x2', '\x2', '\xA0', 
		'\x11', '\x3', '\x2', '\x2', '\x2', '\xA1', '\x9F', '\x3', '\x2', '\x2', 
		'\x2', '\xA2', '\xA3', '\a', 'I', '\x2', '\x2', '\xA3', '\xA4', '\x5', 
		'\x1A', '\xE', '\x2', '\xA4', '\x13', '\x3', '\x2', '\x2', '\x2', '\xA5', 
		'\xA6', '\x5', '\x16', '\f', '\x2', '\xA6', '\xA7', '\x5', '>', ' ', '\x2', 
		'\xA7', '\xA8', '\a', '\x1A', '\x2', '\x2', '\xA8', '\x15', '\x3', '\x2', 
		'\x2', '\x2', '\xA9', '\xAA', '\a', '\x11', '\x2', '\x2', '\xAA', '\xAB', 
		'\a', 'I', '\x2', '\x2', '\xAB', '\xAE', '\a', '\x18', '\x2', '\x2', '\xAC', 
		'\xAF', '\x5', '\x18', '\r', '\x2', '\xAD', '\xAF', '\x3', '\x2', '\x2', 
		'\x2', '\xAE', '\xAC', '\x3', '\x2', '\x2', '\x2', '\xAE', '\xAD', '\x3', 
		'\x2', '\x2', '\x2', '\xAF', '\xB0', '\x3', '\x2', '\x2', '\x2', '\xB0', 
		'\xB3', '\a', '\x19', '\x2', '\x2', '\xB1', '\xB4', '\x5', '\x1A', '\xE', 
		'\x2', '\xB2', '\xB4', '\x3', '\x2', '\x2', '\x2', '\xB3', '\xB1', '\x3', 
		'\x2', '\x2', '\x2', '\xB3', '\xB2', '\x3', '\x2', '\x2', '\x2', '\xB4', 
		'\x17', '\x3', '\x2', '\x2', '\x2', '\xB5', '\xBA', '\x5', '\f', '\a', 
		'\x2', '\xB6', '\xB7', '\a', '\x1C', '\x2', '\x2', '\xB7', '\xB9', '\x5', 
		'\f', '\a', '\x2', '\xB8', '\xB6', '\x3', '\x2', '\x2', '\x2', '\xB9', 
		'\xBC', '\x3', '\x2', '\x2', '\x2', '\xBA', '\xB8', '\x3', '\x2', '\x2', 
		'\x2', '\xBA', '\xBB', '\x3', '\x2', '\x2', '\x2', '\xBB', '\x19', '\x3', 
		'\x2', '\x2', '\x2', '\xBC', '\xBA', '\x3', '\x2', '\x2', '\x2', '\xBD', 
		'\xBE', '\a', '\x18', '\x2', '\x2', '\xBE', '\xBF', '\x5', '\x1A', '\xE', 
		'\x2', '\xBF', '\xC0', '\a', '\x19', '\x2', '\x2', '\xC0', '\xC6', '\x3', 
		'\x2', '\x2', '\x2', '\xC1', '\xC6', '\a', 'I', '\x2', '\x2', '\xC2', 
		'\xC6', '\x5', '\x1C', '\xF', '\x2', '\xC3', '\xC6', '\x5', '\x1E', '\x10', 
		'\x2', '\xC4', '\xC6', '\x5', ' ', '\x11', '\x2', '\xC5', '\xBD', '\x3', 
		'\x2', '\x2', '\x2', '\xC5', '\xC1', '\x3', '\x2', '\x2', '\x2', '\xC5', 
		'\xC2', '\x3', '\x2', '\x2', '\x2', '\xC5', '\xC3', '\x3', '\x2', '\x2', 
		'\x2', '\xC5', '\xC4', '\x3', '\x2', '\x2', '\x2', '\xC6', '\x1B', '\x3', 
		'\x2', '\x2', '\x2', '\xC7', '\xC8', '\a', '\x1E', '\x2', '\x2', '\xC8', 
		'\xC9', '\a', '\x1F', '\x2', '\x2', '\xC9', '\xCA', '\x5', '\x1A', '\xE', 
		'\x2', '\xCA', '\x1D', '\x3', '\x2', '\x2', '\x2', '\xCB', '\xCC', '\a', 
		'\x1E', '\x2', '\x2', '\xCC', '\xCD', '\a', 'K', '\x2', '\x2', '\xCD', 
		'\xCE', '\a', '\x1F', '\x2', '\x2', '\xCE', '\xCF', '\x5', '\x1A', '\xE', 
		'\x2', '\xCF', '\x1F', '\x3', '\x2', '\x2', '\x2', '\xD0', '\xD1', '\a', 
		'\a', '\x2', '\x2', '\xD1', '\xD4', '\a', ' ', '\x2', '\x2', '\xD2', '\xD5', 
		'\x5', '\"', '\x12', '\x2', '\xD3', '\xD5', '\x3', '\x2', '\x2', '\x2', 
		'\xD4', '\xD2', '\x3', '\x2', '\x2', '\x2', '\xD4', '\xD3', '\x3', '\x2', 
		'\x2', '\x2', '\xD5', '\xD6', '\x3', '\x2', '\x2', '\x2', '\xD6', '\xD7', 
		'\a', '!', '\x2', '\x2', '\xD7', '!', '\x3', '\x2', '\x2', '\x2', '\xD8', 
		'\xD9', '\x5', '\f', '\a', '\x2', '\xD9', '\xDF', '\a', '\x1A', '\x2', 
		'\x2', '\xDA', '\xDB', '\x5', '\f', '\a', '\x2', '\xDB', '\xDC', '\a', 
		'\x1A', '\x2', '\x2', '\xDC', '\xDE', '\x3', '\x2', '\x2', '\x2', '\xDD', 
		'\xDA', '\x3', '\x2', '\x2', '\x2', '\xDE', '\xE1', '\x3', '\x2', '\x2', 
		'\x2', '\xDF', '\xDD', '\x3', '\x2', '\x2', '\x2', '\xDF', '\xE0', '\x3', 
		'\x2', '\x2', '\x2', '\xE0', '#', '\x3', '\x2', '\x2', '\x2', '\xE1', 
		'\xDF', '\x3', '\x2', '\x2', '\x2', '\xE2', '\xE7', '\a', 'I', '\x2', 
		'\x2', '\xE3', '\xE4', '\a', '\x1C', '\x2', '\x2', '\xE4', '\xE6', '\a', 
		'I', '\x2', '\x2', '\xE5', '\xE3', '\x3', '\x2', '\x2', '\x2', '\xE6', 
		'\xE9', '\x3', '\x2', '\x2', '\x2', '\xE7', '\xE5', '\x3', '\x2', '\x2', 
		'\x2', '\xE7', '\xE8', '\x3', '\x2', '\x2', '\x2', '\xE8', '%', '\x3', 
		'\x2', '\x2', '\x2', '\xE9', '\xE7', '\x3', '\x2', '\x2', '\x2', '\xEA', 
		'\xEB', '\b', '\x14', '\x1', '\x2', '\xEB', '\xF5', '\x5', '*', '\x16', 
		'\x2', '\xEC', '\xED', '\a', '*', '\x2', '\x2', '\xED', '\xF5', '\x5', 
		'&', '\x14', '\x6', '\xEE', '\xEF', '\a', '+', '\x2', '\x2', '\xEF', '\xF5', 
		'\x5', '&', '\x14', '\x5', '\xF0', '\xF1', '\a', '\"', '\x2', '\x2', '\xF1', 
		'\xF5', '\x5', '&', '\x14', '\x4', '\xF2', '\xF3', '\a', '-', '\x2', '\x2', 
		'\xF3', '\xF5', '\x5', '&', '\x14', '\x3', '\xF4', '\xEA', '\x3', '\x2', 
		'\x2', '\x2', '\xF4', '\xEC', '\x3', '\x2', '\x2', '\x2', '\xF4', '\xEE', 
		'\x3', '\x2', '\x2', '\x2', '\xF4', '\xF0', '\x3', '\x2', '\x2', '\x2', 
		'\xF4', '\xF2', '\x3', '\x2', '\x2', '\x2', '\xF5', '\x131', '\x3', '\x2', 
		'\x2', '\x2', '\xF6', '\xF7', '\f', '\x19', '\x2', '\x2', '\xF7', '\xF8', 
		'\a', '#', '\x2', '\x2', '\xF8', '\x130', '\x5', '&', '\x14', '\x1A', 
		'\xF9', '\xFA', '\f', '\x18', '\x2', '\x2', '\xFA', '\xFB', '\a', '$', 
		'\x2', '\x2', '\xFB', '\x130', '\x5', '&', '\x14', '\x19', '\xFC', '\xFD', 
		'\f', '\x17', '\x2', '\x2', '\xFD', '\xFE', '\a', '%', '\x2', '\x2', '\xFE', 
		'\x130', '\x5', '&', '\x14', '\x18', '\xFF', '\x100', '\f', '\x16', '\x2', 
		'\x2', '\x100', '\x101', '\a', '&', '\x2', '\x2', '\x101', '\x130', '\x5', 
		'&', '\x14', '\x17', '\x102', '\x103', '\f', '\x15', '\x2', '\x2', '\x103', 
		'\x104', '\a', '\'', '\x2', '\x2', '\x104', '\x130', '\x5', '&', '\x14', 
		'\x16', '\x105', '\x106', '\f', '\x14', '\x2', '\x2', '\x106', '\x107', 
		'\a', '(', '\x2', '\x2', '\x107', '\x130', '\x5', '&', '\x14', '\x15', 
		'\x108', '\x109', '\f', '\x13', '\x2', '\x2', '\x109', '\x10A', '\a', 
		')', '\x2', '\x2', '\x10A', '\x130', '\x5', '&', '\x14', '\x14', '\x10B', 
		'\x10C', '\f', '\x12', '\x2', '\x2', '\x10C', '\x10D', '\a', '*', '\x2', 
		'\x2', '\x10D', '\x130', '\x5', '&', '\x14', '\x13', '\x10E', '\x10F', 
		'\f', '\x11', '\x2', '\x2', '\x10F', '\x110', '\a', '+', '\x2', '\x2', 
		'\x110', '\x130', '\x5', '&', '\x14', '\x12', '\x111', '\x112', '\f', 
		'\x10', '\x2', '\x2', '\x112', '\x113', '\a', ',', '\x2', '\x2', '\x113', 
		'\x130', '\x5', '&', '\x14', '\x11', '\x114', '\x115', '\f', '\xF', '\x2', 
		'\x2', '\x115', '\x116', '\a', '-', '\x2', '\x2', '\x116', '\x130', '\x5', 
		'&', '\x14', '\x10', '\x117', '\x118', '\f', '\xE', '\x2', '\x2', '\x118', 
		'\x119', '\a', '.', '\x2', '\x2', '\x119', '\x130', '\x5', '&', '\x14', 
		'\xF', '\x11A', '\x11B', '\f', '\r', '\x2', '\x2', '\x11B', '\x11C', '\a', 
		'/', '\x2', '\x2', '\x11C', '\x130', '\x5', '&', '\x14', '\xE', '\x11D', 
		'\x11E', '\f', '\f', '\x2', '\x2', '\x11E', '\x11F', '\a', '\x31', '\x2', 
		'\x2', '\x11F', '\x130', '\x5', '&', '\x14', '\r', '\x120', '\x121', '\f', 
		'\v', '\x2', '\x2', '\x121', '\x122', '\a', '\x32', '\x2', '\x2', '\x122', 
		'\x130', '\x5', '&', '\x14', '\f', '\x123', '\x124', '\f', '\n', '\x2', 
		'\x2', '\x124', '\x125', '\a', '\x30', '\x2', '\x2', '\x125', '\x130', 
		'\x5', '&', '\x14', '\v', '\x126', '\x127', '\f', '\t', '\x2', '\x2', 
		'\x127', '\x128', '\a', '\x33', '\x2', '\x2', '\x128', '\x130', '\x5', 
		'&', '\x14', '\n', '\x129', '\x12A', '\f', '\b', '\x2', '\x2', '\x12A', 
		'\x12B', '\a', '\x34', '\x2', '\x2', '\x12B', '\x130', '\x5', '&', '\x14', 
		'\t', '\x12C', '\x12D', '\f', '\a', '\x2', '\x2', '\x12D', '\x12E', '\a', 
		'\x35', '\x2', '\x2', '\x12E', '\x130', '\x5', '&', '\x14', '\b', '\x12F', 
		'\xF6', '\x3', '\x2', '\x2', '\x2', '\x12F', '\xF9', '\x3', '\x2', '\x2', 
		'\x2', '\x12F', '\xFC', '\x3', '\x2', '\x2', '\x2', '\x12F', '\xFF', '\x3', 
		'\x2', '\x2', '\x2', '\x12F', '\x102', '\x3', '\x2', '\x2', '\x2', '\x12F', 
		'\x105', '\x3', '\x2', '\x2', '\x2', '\x12F', '\x108', '\x3', '\x2', '\x2', 
		'\x2', '\x12F', '\x10B', '\x3', '\x2', '\x2', '\x2', '\x12F', '\x10E', 
		'\x3', '\x2', '\x2', '\x2', '\x12F', '\x111', '\x3', '\x2', '\x2', '\x2', 
		'\x12F', '\x114', '\x3', '\x2', '\x2', '\x2', '\x12F', '\x117', '\x3', 
		'\x2', '\x2', '\x2', '\x12F', '\x11A', '\x3', '\x2', '\x2', '\x2', '\x12F', 
		'\x11D', '\x3', '\x2', '\x2', '\x2', '\x12F', '\x120', '\x3', '\x2', '\x2', 
		'\x2', '\x12F', '\x123', '\x3', '\x2', '\x2', '\x2', '\x12F', '\x126', 
		'\x3', '\x2', '\x2', '\x2', '\x12F', '\x129', '\x3', '\x2', '\x2', '\x2', 
		'\x12F', '\x12C', '\x3', '\x2', '\x2', '\x2', '\x130', '\x133', '\x3', 
		'\x2', '\x2', '\x2', '\x131', '\x12F', '\x3', '\x2', '\x2', '\x2', '\x131', 
		'\x132', '\x3', '\x2', '\x2', '\x2', '\x132', '\'', '\x3', '\x2', '\x2', 
		'\x2', '\x133', '\x131', '\x3', '\x2', '\x2', '\x2', '\x134', '\x139', 
		'\x5', '&', '\x14', '\x2', '\x135', '\x136', '\a', '\x1C', '\x2', '\x2', 
		'\x136', '\x138', '\x5', '&', '\x14', '\x2', '\x137', '\x135', '\x3', 
		'\x2', '\x2', '\x2', '\x138', '\x13B', '\x3', '\x2', '\x2', '\x2', '\x139', 
		'\x137', '\x3', '\x2', '\x2', '\x2', '\x139', '\x13A', '\x3', '\x2', '\x2', 
		'\x2', '\x13A', ')', '\x3', '\x2', '\x2', '\x2', '\x13B', '\x139', '\x3', 
		'\x2', '\x2', '\x2', '\x13C', '\x13D', '\b', '\x16', '\x1', '\x2', '\x13D', 
		'\x142', '\x5', ',', '\x17', '\x2', '\x13E', '\x142', '\x5', '\x36', '\x1C', 
		'\x2', '\x13F', '\x142', '\x5', '\x38', '\x1D', '\x2', '\x140', '\x142', 
		'\x5', ':', '\x1E', '\x2', '\x141', '\x13C', '\x3', '\x2', '\x2', '\x2', 
		'\x141', '\x13E', '\x3', '\x2', '\x2', '\x2', '\x141', '\x13F', '\x3', 
		'\x2', '\x2', '\x2', '\x141', '\x140', '\x3', '\x2', '\x2', '\x2', '\x142', 
		'\x14B', '\x3', '\x2', '\x2', '\x2', '\x143', '\x144', '\f', '\b', '\x2', 
		'\x2', '\x144', '\x14A', '\x5', '\x34', '\x1B', '\x2', '\x145', '\x146', 
		'\f', '\a', '\x2', '\x2', '\x146', '\x14A', '\x5', '\x30', '\x19', '\x2', 
		'\x147', '\x148', '\f', '\x6', '\x2', '\x2', '\x148', '\x14A', '\x5', 
		'\x32', '\x1A', '\x2', '\x149', '\x143', '\x3', '\x2', '\x2', '\x2', '\x149', 
		'\x145', '\x3', '\x2', '\x2', '\x2', '\x149', '\x147', '\x3', '\x2', '\x2', 
		'\x2', '\x14A', '\x14D', '\x3', '\x2', '\x2', '\x2', '\x14B', '\x149', 
		'\x3', '\x2', '\x2', '\x2', '\x14B', '\x14C', '\x3', '\x2', '\x2', '\x2', 
		'\x14C', '+', '\x3', '\x2', '\x2', '\x2', '\x14D', '\x14B', '\x3', '\x2', 
		'\x2', '\x2', '\x14E', '\x155', '\x5', '.', '\x18', '\x2', '\x14F', '\x155', 
		'\a', 'I', '\x2', '\x2', '\x150', '\x151', '\a', '\x18', '\x2', '\x2', 
		'\x151', '\x152', '\x5', '&', '\x14', '\x2', '\x152', '\x153', '\a', '\x19', 
		'\x2', '\x2', '\x153', '\x155', '\x3', '\x2', '\x2', '\x2', '\x154', '\x14E', 
		'\x3', '\x2', '\x2', '\x2', '\x154', '\x14F', '\x3', '\x2', '\x2', '\x2', 
		'\x154', '\x150', '\x3', '\x2', '\x2', '\x2', '\x155', '-', '\x3', '\x2', 
		'\x2', '\x2', '\x156', '\x15C', '\a', 'K', '\x2', '\x2', '\x157', '\x15C', 
		'\a', 'T', '\x2', '\x2', '\x158', '\x15C', '\a', '\\', '\x2', '\x2', '\x159', 
		'\x15C', '\a', 'Z', '\x2', '\x2', '\x15A', '\x15C', '\a', '[', '\x2', 
		'\x2', '\x15B', '\x156', '\x3', '\x2', '\x2', '\x2', '\x15B', '\x157', 
		'\x3', '\x2', '\x2', '\x2', '\x15B', '\x158', '\x3', '\x2', '\x2', '\x2', 
		'\x15B', '\x159', '\x3', '\x2', '\x2', '\x2', '\x15B', '\x15A', '\x3', 
		'\x2', '\x2', '\x2', '\x15C', '/', '\x3', '\x2', '\x2', '\x2', '\x15D', 
		'\x15E', '\a', '\x1E', '\x2', '\x2', '\x15E', '\x15F', '\x5', '&', '\x14', 
		'\x2', '\x15F', '\x160', '\a', '\x1F', '\x2', '\x2', '\x160', '\x31', 
		'\x3', '\x2', '\x2', '\x2', '\x161', '\x164', '\a', '\x18', '\x2', '\x2', 
		'\x162', '\x165', '\x5', '(', '\x15', '\x2', '\x163', '\x165', '\x3', 
		'\x2', '\x2', '\x2', '\x164', '\x162', '\x3', '\x2', '\x2', '\x2', '\x164', 
		'\x163', '\x3', '\x2', '\x2', '\x2', '\x165', '\x166', '\x3', '\x2', '\x2', 
		'\x2', '\x166', '\x167', '\a', '\x19', '\x2', '\x2', '\x167', '\x33', 
		'\x3', '\x2', '\x2', '\x2', '\x168', '\x169', '\a', '\x36', '\x2', '\x2', 
		'\x169', '\x16A', '\a', 'I', '\x2', '\x2', '\x16A', '\x35', '\x3', '\x2', 
		'\x2', '\x2', '\x16B', '\x16C', '\a', '\b', '\x2', '\x2', '\x16C', '\x16D', 
		'\a', '\x18', '\x2', '\x2', '\x16D', '\x16E', '\x5', '&', '\x14', '\x2', 
		'\x16E', '\x16F', '\a', '\x1C', '\x2', '\x2', '\x16F', '\x170', '\x5', 
		'&', '\x14', '\x2', '\x170', '\x171', '\a', '\x19', '\x2', '\x2', '\x171', 
		'\x37', '\x3', '\x2', '\x2', '\x2', '\x172', '\x173', '\a', '\t', '\x2', 
		'\x2', '\x173', '\x174', '\a', '\x18', '\x2', '\x2', '\x174', '\x175', 
		'\x5', '&', '\x14', '\x2', '\x175', '\x176', '\a', '\x19', '\x2', '\x2', 
		'\x176', '\x39', '\x3', '\x2', '\x2', '\x2', '\x177', '\x178', '\a', '\n', 
		'\x2', '\x2', '\x178', '\x179', '\a', '\x18', '\x2', '\x2', '\x179', '\x17A', 
		'\x5', '&', '\x14', '\x2', '\x17A', '\x17B', '\a', '\x19', '\x2', '\x2', 
		'\x17B', ';', '\x3', '\x2', '\x2', '\x2', '\x17C', '\x17E', '\x5', '@', 
		'!', '\x2', '\x17D', '\x17C', '\x3', '\x2', '\x2', '\x2', '\x17E', '\x181', 
		'\x3', '\x2', '\x2', '\x2', '\x17F', '\x17D', '\x3', '\x2', '\x2', '\x2', 
		'\x17F', '\x180', '\x3', '\x2', '\x2', '\x2', '\x180', '=', '\x3', '\x2', 
		'\x2', '\x2', '\x181', '\x17F', '\x3', '\x2', '\x2', '\x2', '\x182', '\x183', 
		'\a', ' ', '\x2', '\x2', '\x183', '\x184', '\x5', '<', '\x1F', '\x2', 
		'\x184', '\x185', '\a', '!', '\x2', '\x2', '\x185', '?', '\x3', '\x2', 
		'\x2', '\x2', '\x186', '\x187', '\a', '\v', '\x2', '\x2', '\x187', '\x18A', 
		'\a', '\x18', '\x2', '\x2', '\x188', '\x18B', '\x5', '(', '\x15', '\x2', 
		'\x189', '\x18B', '\x3', '\x2', '\x2', '\x2', '\x18A', '\x188', '\x3', 
		'\x2', '\x2', '\x2', '\x18A', '\x189', '\x3', '\x2', '\x2', '\x2', '\x18B', 
		'\x18C', '\x3', '\x2', '\x2', '\x2', '\x18C', '\x18D', '\a', '\x19', '\x2', 
		'\x2', '\x18D', '\x1B2', '\a', '\x1A', '\x2', '\x2', '\x18E', '\x18F', 
		'\a', '\f', '\x2', '\x2', '\x18F', '\x192', '\a', '\x18', '\x2', '\x2', 
		'\x190', '\x193', '\x5', '(', '\x15', '\x2', '\x191', '\x193', '\a', 'Z', 
		'\x2', '\x2', '\x192', '\x190', '\x3', '\x2', '\x2', '\x2', '\x192', '\x191', 
		'\x3', '\x2', '\x2', '\x2', '\x193', '\x194', '\x3', '\x2', '\x2', '\x2', 
		'\x194', '\x195', '\a', '\x19', '\x2', '\x2', '\x195', '\x1B2', '\a', 
		'\x1A', '\x2', '\x2', '\x196', '\x199', '\a', '\r', '\x2', '\x2', '\x197', 
		'\x19A', '\x5', '&', '\x14', '\x2', '\x198', '\x19A', '\x3', '\x2', '\x2', 
		'\x2', '\x199', '\x197', '\x3', '\x2', '\x2', '\x2', '\x199', '\x198', 
		'\x3', '\x2', '\x2', '\x2', '\x19A', '\x19B', '\x3', '\x2', '\x2', '\x2', 
		'\x19B', '\x1B2', '\a', '\x1A', '\x2', '\x2', '\x19C', '\x19D', '\a', 
		'\xE', '\x2', '\x2', '\x19D', '\x1B2', '\a', '\x1A', '\x2', '\x2', '\x19E', 
		'\x19F', '\a', '\xF', '\x2', '\x2', '\x19F', '\x1B2', '\a', '\x1A', '\x2', 
		'\x2', '\x1A0', '\x1A1', '\x5', '\x42', '\"', '\x2', '\x1A1', '\x1A2', 
		'\a', '\x1A', '\x2', '\x2', '\x1A2', '\x1B2', '\x3', '\x2', '\x2', '\x2', 
		'\x1A3', '\x1A4', '\x5', '>', ' ', '\x2', '\x1A4', '\x1A5', '\a', '\x1A', 
		'\x2', '\x2', '\x1A5', '\x1B2', '\x3', '\x2', '\x2', '\x2', '\x1A6', '\x1A7', 
		'\x5', 'J', '&', '\x2', '\x1A7', '\x1A8', '\a', '\x1A', '\x2', '\x2', 
		'\x1A8', '\x1B2', '\x3', '\x2', '\x2', '\x2', '\x1A9', '\x1AA', '\x5', 
		'\x46', '$', '\x2', '\x1AA', '\x1AB', '\a', '\x1A', '\x2', '\x2', '\x1AB', 
		'\x1B2', '\x3', '\x2', '\x2', '\x2', '\x1AC', '\x1AD', '\x5', 'H', '%', 
		'\x2', '\x1AD', '\x1AE', '\a', '\x1A', '\x2', '\x2', '\x1AE', '\x1B2', 
		'\x3', '\x2', '\x2', '\x2', '\x1AF', '\x1B2', '\x5', '\xE', '\b', '\x2', 
		'\x1B0', '\x1B2', '\x5', '\x6', '\x4', '\x2', '\x1B1', '\x186', '\x3', 
		'\x2', '\x2', '\x2', '\x1B1', '\x18E', '\x3', '\x2', '\x2', '\x2', '\x1B1', 
		'\x196', '\x3', '\x2', '\x2', '\x2', '\x1B1', '\x19C', '\x3', '\x2', '\x2', 
		'\x2', '\x1B1', '\x19E', '\x3', '\x2', '\x2', '\x2', '\x1B1', '\x1A0', 
		'\x3', '\x2', '\x2', '\x2', '\x1B1', '\x1A3', '\x3', '\x2', '\x2', '\x2', 
		'\x1B1', '\x1A6', '\x3', '\x2', '\x2', '\x2', '\x1B1', '\x1A9', '\x3', 
		'\x2', '\x2', '\x2', '\x1B1', '\x1AC', '\x3', '\x2', '\x2', '\x2', '\x1B1', 
		'\x1AF', '\x3', '\x2', '\x2', '\x2', '\x1B1', '\x1B0', '\x3', '\x2', '\x2', 
		'\x2', '\x1B2', '\x41', '\x3', '\x2', '\x2', '\x2', '\x1B3', '\x1C0', 
		'\x3', '\x2', '\x2', '\x2', '\x1B4', '\x1B8', '\x5', '&', '\x14', '\x2', 
		'\x1B5', '\x1B9', '\a', '\x37', '\x2', '\x2', '\x1B6', '\x1B9', '\a', 
		'\x38', '\x2', '\x2', '\x1B7', '\x1B9', '\x3', '\x2', '\x2', '\x2', '\x1B8', 
		'\x1B5', '\x3', '\x2', '\x2', '\x2', '\x1B8', '\x1B6', '\x3', '\x2', '\x2', 
		'\x2', '\x1B8', '\x1B7', '\x3', '\x2', '\x2', '\x2', '\x1B9', '\x1C0', 
		'\x3', '\x2', '\x2', '\x2', '\x1BA', '\x1C0', '\x5', '\x44', '#', '\x2', 
		'\x1BB', '\x1BC', '\x5', '(', '\x15', '\x2', '\x1BC', '\x1BD', '\a', '\x39', 
		'\x2', '\x2', '\x1BD', '\x1BE', '\x5', '(', '\x15', '\x2', '\x1BE', '\x1C0', 
		'\x3', '\x2', '\x2', '\x2', '\x1BF', '\x1B3', '\x3', '\x2', '\x2', '\x2', 
		'\x1BF', '\x1B4', '\x3', '\x2', '\x2', '\x2', '\x1BF', '\x1BA', '\x3', 
		'\x2', '\x2', '\x2', '\x1BF', '\x1BB', '\x3', '\x2', '\x2', '\x2', '\x1C0', 
		'\x43', '\x3', '\x2', '\x2', '\x2', '\x1C1', '\x1C2', '\x5', '(', '\x15', 
		'\x2', '\x1C2', '\x1C3', '\a', '\x1B', '\x2', '\x2', '\x1C3', '\x1C4', 
		'\x5', '(', '\x15', '\x2', '\x1C4', '\x1F2', '\x3', '\x2', '\x2', '\x2', 
		'\x1C5', '\x1C6', '\x5', '&', '\x14', '\x2', '\x1C6', '\x1C7', '\a', ':', 
		'\x2', '\x2', '\x1C7', '\x1C8', '\x5', '&', '\x14', '\x2', '\x1C8', '\x1F2', 
		'\x3', '\x2', '\x2', '\x2', '\x1C9', '\x1CA', '\x5', '&', '\x14', '\x2', 
		'\x1CA', '\x1CB', '\a', '<', '\x2', '\x2', '\x1CB', '\x1CC', '\x5', '&', 
		'\x14', '\x2', '\x1CC', '\x1F2', '\x3', '\x2', '\x2', '\x2', '\x1CD', 
		'\x1CE', '\x5', '&', '\x14', '\x2', '\x1CE', '\x1CF', '\a', ';', '\x2', 
		'\x2', '\x1CF', '\x1D0', '\x5', '&', '\x14', '\x2', '\x1D0', '\x1F2', 
		'\x3', '\x2', '\x2', '\x2', '\x1D1', '\x1D2', '\x5', '&', '\x14', '\x2', 
		'\x1D2', '\x1D3', '\a', '=', '\x2', '\x2', '\x1D3', '\x1D4', '\x5', '&', 
		'\x14', '\x2', '\x1D4', '\x1F2', '\x3', '\x2', '\x2', '\x2', '\x1D5', 
		'\x1D6', '\x5', '&', '\x14', '\x2', '\x1D6', '\x1D7', '\a', '>', '\x2', 
		'\x2', '\x1D7', '\x1D8', '\x5', '&', '\x14', '\x2', '\x1D8', '\x1F2', 
		'\x3', '\x2', '\x2', '\x2', '\x1D9', '\x1DA', '\x5', '&', '\x14', '\x2', 
		'\x1DA', '\x1DB', '\a', '?', '\x2', '\x2', '\x1DB', '\x1DC', '\x5', '&', 
		'\x14', '\x2', '\x1DC', '\x1F2', '\x3', '\x2', '\x2', '\x2', '\x1DD', 
		'\x1DE', '\x5', '&', '\x14', '\x2', '\x1DE', '\x1DF', '\a', '@', '\x2', 
		'\x2', '\x1DF', '\x1E0', '\x5', '&', '\x14', '\x2', '\x1E0', '\x1F2', 
		'\x3', '\x2', '\x2', '\x2', '\x1E1', '\x1E2', '\x5', '&', '\x14', '\x2', 
		'\x1E2', '\x1E3', '\a', '\x41', '\x2', '\x2', '\x1E3', '\x1E4', '\x5', 
		'&', '\x14', '\x2', '\x1E4', '\x1F2', '\x3', '\x2', '\x2', '\x2', '\x1E5', 
		'\x1E6', '\x5', '&', '\x14', '\x2', '\x1E6', '\x1E7', '\a', '\x42', '\x2', 
		'\x2', '\x1E7', '\x1E8', '\x5', '&', '\x14', '\x2', '\x1E8', '\x1F2', 
		'\x3', '\x2', '\x2', '\x2', '\x1E9', '\x1EA', '\x5', '&', '\x14', '\x2', 
		'\x1EA', '\x1EB', '\a', '\x43', '\x2', '\x2', '\x1EB', '\x1EC', '\x5', 
		'&', '\x14', '\x2', '\x1EC', '\x1F2', '\x3', '\x2', '\x2', '\x2', '\x1ED', 
		'\x1EE', '\x5', '&', '\x14', '\x2', '\x1EE', '\x1EF', '\a', '\x44', '\x2', 
		'\x2', '\x1EF', '\x1F0', '\x5', '&', '\x14', '\x2', '\x1F0', '\x1F2', 
		'\x3', '\x2', '\x2', '\x2', '\x1F1', '\x1C1', '\x3', '\x2', '\x2', '\x2', 
		'\x1F1', '\x1C5', '\x3', '\x2', '\x2', '\x2', '\x1F1', '\x1C9', '\x3', 
		'\x2', '\x2', '\x2', '\x1F1', '\x1CD', '\x3', '\x2', '\x2', '\x2', '\x1F1', 
		'\x1D1', '\x3', '\x2', '\x2', '\x2', '\x1F1', '\x1D5', '\x3', '\x2', '\x2', 
		'\x2', '\x1F1', '\x1D9', '\x3', '\x2', '\x2', '\x2', '\x1F1', '\x1DD', 
		'\x3', '\x2', '\x2', '\x2', '\x1F1', '\x1E1', '\x3', '\x2', '\x2', '\x2', 
		'\x1F1', '\x1E5', '\x3', '\x2', '\x2', '\x2', '\x1F1', '\x1E9', '\x3', 
		'\x2', '\x2', '\x2', '\x1F1', '\x1ED', '\x3', '\x2', '\x2', '\x2', '\x1F2', 
		'\x45', '\x3', '\x2', '\x2', '\x2', '\x1F3', '\x1F4', '\a', '\x10', '\x2', 
		'\x2', '\x1F4', '\x1F5', '\x5', '&', '\x14', '\x2', '\x1F5', '\x1F6', 
		'\x5', '>', ' ', '\x2', '\x1F6', '\x21A', '\x3', '\x2', '\x2', '\x2', 
		'\x1F7', '\x1F8', '\a', '\x10', '\x2', '\x2', '\x1F8', '\x1F9', '\x5', 
		'&', '\x14', '\x2', '\x1F9', '\x1FA', '\x5', '>', ' ', '\x2', '\x1FA', 
		'\x1FB', '\a', '\x12', '\x2', '\x2', '\x1FB', '\x1FC', '\x5', '\x46', 
		'$', '\x2', '\x1FC', '\x21A', '\x3', '\x2', '\x2', '\x2', '\x1FD', '\x1FE', 
		'\a', '\x10', '\x2', '\x2', '\x1FE', '\x1FF', '\x5', '&', '\x14', '\x2', 
		'\x1FF', '\x200', '\x5', '>', ' ', '\x2', '\x200', '\x201', '\a', '\x12', 
		'\x2', '\x2', '\x201', '\x202', '\x5', '>', ' ', '\x2', '\x202', '\x21A', 
		'\x3', '\x2', '\x2', '\x2', '\x203', '\x204', '\a', '\x10', '\x2', '\x2', 
		'\x204', '\x205', '\x5', '\x42', '\"', '\x2', '\x205', '\x206', '\a', 
		'\x1A', '\x2', '\x2', '\x206', '\x207', '\x5', '&', '\x14', '\x2', '\x207', 
		'\x208', '\x5', '>', ' ', '\x2', '\x208', '\x21A', '\x3', '\x2', '\x2', 
		'\x2', '\x209', '\x20A', '\a', '\x10', '\x2', '\x2', '\x20A', '\x20B', 
		'\x5', '\x42', '\"', '\x2', '\x20B', '\x20C', '\a', '\x1A', '\x2', '\x2', 
		'\x20C', '\x20D', '\x5', '&', '\x14', '\x2', '\x20D', '\x20E', '\x5', 
		'>', ' ', '\x2', '\x20E', '\x20F', '\a', '\x12', '\x2', '\x2', '\x20F', 
		'\x210', '\x5', '\x46', '$', '\x2', '\x210', '\x21A', '\x3', '\x2', '\x2', 
		'\x2', '\x211', '\x212', '\a', '\x10', '\x2', '\x2', '\x212', '\x213', 
		'\x5', '\x42', '\"', '\x2', '\x213', '\x214', '\a', '\x1A', '\x2', '\x2', 
		'\x214', '\x215', '\x5', '&', '\x14', '\x2', '\x215', '\x216', '\x5', 
		'>', ' ', '\x2', '\x216', '\x217', '\a', '\x12', '\x2', '\x2', '\x217', 
		'\x218', '\x5', '>', ' ', '\x2', '\x218', '\x21A', '\x3', '\x2', '\x2', 
		'\x2', '\x219', '\x1F3', '\x3', '\x2', '\x2', '\x2', '\x219', '\x1F7', 
		'\x3', '\x2', '\x2', '\x2', '\x219', '\x1FD', '\x3', '\x2', '\x2', '\x2', 
		'\x219', '\x203', '\x3', '\x2', '\x2', '\x2', '\x219', '\x209', '\x3', 
		'\x2', '\x2', '\x2', '\x219', '\x211', '\x3', '\x2', '\x2', '\x2', '\x21A', 
		'G', '\x3', '\x2', '\x2', '\x2', '\x21B', '\x21C', '\a', '\x13', '\x2', 
		'\x2', '\x21C', '\x231', '\x5', '>', ' ', '\x2', '\x21D', '\x21E', '\a', 
		'\x13', '\x2', '\x2', '\x21E', '\x21F', '\x5', '&', '\x14', '\x2', '\x21F', 
		'\x220', '\x5', '>', ' ', '\x2', '\x220', '\x231', '\x3', '\x2', '\x2', 
		'\x2', '\x221', '\x222', '\a', '\x13', '\x2', '\x2', '\x222', '\x223', 
		'\x5', '\x42', '\"', '\x2', '\x223', '\x224', '\a', '\x1A', '\x2', '\x2', 
		'\x224', '\x225', '\x5', '&', '\x14', '\x2', '\x225', '\x226', '\a', '\x1A', 
		'\x2', '\x2', '\x226', '\x227', '\x5', '\x42', '\"', '\x2', '\x227', '\x228', 
		'\x5', '>', ' ', '\x2', '\x228', '\x231', '\x3', '\x2', '\x2', '\x2', 
		'\x229', '\x22A', '\a', '\x13', '\x2', '\x2', '\x22A', '\x22B', '\x5', 
		'\x42', '\"', '\x2', '\x22B', '\x22C', '\a', '\x1A', '\x2', '\x2', '\x22C', 
		'\x22D', '\a', '\x1A', '\x2', '\x2', '\x22D', '\x22E', '\x5', '\x42', 
		'\"', '\x2', '\x22E', '\x22F', '\x5', '>', ' ', '\x2', '\x22F', '\x231', 
		'\x3', '\x2', '\x2', '\x2', '\x230', '\x21B', '\x3', '\x2', '\x2', '\x2', 
		'\x230', '\x21D', '\x3', '\x2', '\x2', '\x2', '\x230', '\x221', '\x3', 
		'\x2', '\x2', '\x2', '\x230', '\x229', '\x3', '\x2', '\x2', '\x2', '\x231', 
		'I', '\x3', '\x2', '\x2', '\x2', '\x232', '\x233', '\a', '\x14', '\x2', 
		'\x2', '\x233', '\x234', '\x5', '\x42', '\"', '\x2', '\x234', '\x235', 
		'\a', '\x1A', '\x2', '\x2', '\x235', '\x236', '\x5', '&', '\x14', '\x2', 
		'\x236', '\x237', '\a', ' ', '\x2', '\x2', '\x237', '\x238', '\x5', 'L', 
		'\'', '\x2', '\x238', '\x239', '\a', '!', '\x2', '\x2', '\x239', '\x24D', 
		'\x3', '\x2', '\x2', '\x2', '\x23A', '\x23B', '\a', '\x14', '\x2', '\x2', 
		'\x23B', '\x23C', '\x5', '&', '\x14', '\x2', '\x23C', '\x23D', '\a', ' ', 
		'\x2', '\x2', '\x23D', '\x23E', '\x5', 'L', '\'', '\x2', '\x23E', '\x23F', 
		'\a', '!', '\x2', '\x2', '\x23F', '\x24D', '\x3', '\x2', '\x2', '\x2', 
		'\x240', '\x241', '\a', '\x14', '\x2', '\x2', '\x241', '\x242', '\x5', 
		'\x42', '\"', '\x2', '\x242', '\x243', '\a', '\x1A', '\x2', '\x2', '\x243', 
		'\x244', '\a', ' ', '\x2', '\x2', '\x244', '\x245', '\x5', 'L', '\'', 
		'\x2', '\x245', '\x246', '\a', '!', '\x2', '\x2', '\x246', '\x24D', '\x3', 
		'\x2', '\x2', '\x2', '\x247', '\x248', '\a', '\x14', '\x2', '\x2', '\x248', 
		'\x249', '\a', ' ', '\x2', '\x2', '\x249', '\x24A', '\x5', 'L', '\'', 
		'\x2', '\x24A', '\x24B', '\a', '!', '\x2', '\x2', '\x24B', '\x24D', '\x3', 
		'\x2', '\x2', '\x2', '\x24C', '\x232', '\x3', '\x2', '\x2', '\x2', '\x24C', 
		'\x23A', '\x3', '\x2', '\x2', '\x2', '\x24C', '\x240', '\x3', '\x2', '\x2', 
		'\x2', '\x24C', '\x247', '\x3', '\x2', '\x2', '\x2', '\x24D', 'K', '\x3', 
		'\x2', '\x2', '\x2', '\x24E', '\x253', '\x3', '\x2', '\x2', '\x2', '\x24F', 
		'\x250', '\x5', 'N', '(', '\x2', '\x250', '\x251', '\x5', 'L', '\'', '\x2', 
		'\x251', '\x253', '\x3', '\x2', '\x2', '\x2', '\x252', '\x24E', '\x3', 
		'\x2', '\x2', '\x2', '\x252', '\x24F', '\x3', '\x2', '\x2', '\x2', '\x253', 
		'M', '\x3', '\x2', '\x2', '\x2', '\x254', '\x255', '\x5', 'P', ')', '\x2', 
		'\x255', '\x256', '\a', '\x1D', '\x2', '\x2', '\x256', '\x257', '\x5', 
		'<', '\x1F', '\x2', '\x257', 'O', '\x3', '\x2', '\x2', '\x2', '\x258', 
		'\x259', '\a', '\x15', '\x2', '\x2', '\x259', '\x25C', '\x5', '(', '\x15', 
		'\x2', '\x25A', '\x25C', '\a', '\x16', '\x2', '\x2', '\x25B', '\x258', 
		'\x3', '\x2', '\x2', '\x2', '\x25B', '\x25A', '\x3', '\x2', '\x2', '\x2', 
		'\x25C', 'Q', '\x3', '\x2', '\x2', '\x2', '\'', 'Z', '\\', 'm', 'v', '\x83', 
		'\x96', '\x9F', '\xAE', '\xB3', '\xBA', '\xC5', '\xD4', '\xDF', '\xE7', 
		'\xF4', '\x12F', '\x131', '\x139', '\x141', '\x149', '\x14B', '\x154', 
		'\x15B', '\x164', '\x17F', '\x18A', '\x192', '\x199', '\x1B1', '\x1B8', 
		'\x1BF', '\x1F1', '\x219', '\x230', '\x24C', '\x252', '\x25B',
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
} // namespace Generated
